{"version":3,"sources":["phone.js"],"names":["Phone","extend","session","connected","default","type","defaultFacingMode","values","registered","namespace","isCallingSupported","resolve","DetectRTC","require","isWebRTCSupported","register","spark","internal","device","refresh","then","all","mercury","when","message","data","bufferState","locus","list","loci","forEach","trigger","make","parent","connect","deregister","disconnect","unregister","createLocalMediaStream","options","constraints","audio","video","initialize","args","prototype","listenTo","event","_onLocusEvent","url","dial","dialString","call"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAMA;;AAEA;;;;AACA;;AACA;;;;AAEA;;;;;;;;;;;;;AAaA;;;;AAzBA;;;;;;AA6BA,IAAMA,QAAQ,uBAAYC,MAAZ,CAAmB;AAC/BC,WAAS;AACP;;;;;;;AAOAC,eAAW;AACTC,eAAS,KADA;AAETC;AAFS,KARJ;AAYP;;;;;;;;;;;;;AAaAC,uBAAmB;AACjBF,qBADiB;AAEjBC,oBAFiB;AAGjBE,cAAQ;AAHS,KAzBZ;AA8BP;;;;;;;;AAQAC,gBAAY;AACVJ,eAAS,KADC;AAEVC;AAFU;AAtCL,GADsB;;AA6C/BI,oBA7C+B;;AA+C/B;;;;;;;;AAQAC,oBAvD+B,gCAuDV;AACnB,WAAO,sBAAY,UAACC,OAAD,EAAa;AAC9B;AACA;AACA;AACA,UAAMC,YAAYC,oBAAlB;AACAF,cAAQC,UAAUE,iBAAlB;AACD,KANM,CAAP;AAOD,GA/D8B;;;AAiE/B;;;;;;;;;AASAC,UA1E+B,sBA0EpB;AAAA;;AACT;AACA;AACA;;AAEA,WAAO,KAAKC,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2BC,OAA3B,GACJC,IADI,CACC,YAAM;AACV,UAAI,MAAKjB,SAAT,EAAoB;AAClB,eAAO,kBAAQQ,OAAR,EAAP;AACD;AACD,aAAO,kBAAQU,GAAR,CAAY,CACjB,MAAKL,KAAL,CAAWC,QAAX,CAAoBK,OAApB,CAA4BC,IAA5B,+BACGH,IADH,CACQ,gBAAe;AAAA;AAAA,YAAbI,OAAa;;AACnB,YAAIA,QAAQC,IAAR,CAAaC,WAAb,CAAyBC,KAAzB,cAAJ,EAAkD;AAChD,iBAAO,MAAKX,KAAL,CAAWC,QAAX,CAAoBU,KAApB,CAA0BC,IAA1B,EAAP;AACD;AACD,eAAO,kBAAQjB,OAAR,EAAP;AACD,OANH,EAOGS,IAPH,CAOQ,UAACS,IAAD,EAAU;AACd,YAAI,CAACA,IAAL,EAAW;AACT;AACD;AACD;AACAA,aAAKC,OAAL,CAAa,UAACH,KAAD,EAAW;AACtB,gBAAKI,OAAL,kBAA8B,eAAKC,IAAL,CAAU;AACtCL;AADsC,WAAV,EAE3B;AACDM,oBAAQ,MAAKjB;AADZ,WAF2B,CAA9B;AAKD,SAND;AAOD,OAnBH,CADiB,EAqBjB,MAAKA,KAAL,CAAWC,QAAX,CAAoBK,OAApB,CAA4BY,OAA5B,EArBiB,CAAZ,CAAP;AAuBD,KA5BI,CAAP;AA6BD,GA5G8B;;;AA8G/B;;;;;;;;AAQAC,YAtH+B,wBAsHlB;AAAA;;AACX,WAAO,KAAKnB,KAAL,CAAWC,QAAX,CAAoBK,OAApB,CAA4Bc,UAA5B,GACJhB,IADI,CACC;AAAA,aAAM,OAAKJ,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2BmB,UAA3B,EAAN;AAAA,KADD,CAAP;AAED,GAzH8B;;;AA2H/B;;;;;;;;;;;AAWAC,wBAtI+B,kCAsIRC,OAtIQ,EAsIC;AAC9BA,cAAUA,WAAW,EAArB;AACA,QAAMC,cAAcD,QAAQC,WAAR,IAAuBD,OAA3C;AACA,4BAASC,WAAT,EAAsB;AACpBC,aAAO,IADa;AAEpBC,aAAO;AAFa,KAAtB;;AAKA,WAAO,0BAAaF,WAAb,CAAP;AACD,GA/I8B;;;AAiJ/B;;;;;;;;;AASAG,YA1J+B,wBA0JX;AAAA;;AAAA,sCAANC,IAAM;AAANA,UAAM;AAAA;;AAClB,yBAAc,uBAAYC,SAAZ,CAAsBF,UAApC,EAAgD,IAAhD,EAAsDC,IAAtD;;AAEA,SAAKE,QAAL,CAAc,KAAK9B,KAAL,CAAWC,QAAX,CAAoBK,OAAlC,iBAA0D,UAACyB,KAAD;AAAA,aAAW,OAAKC,aAAL,CAAmBD,KAAnB,CAAX;AAAA,KAA1D;;AAEA;AACA;AACA,SAAKD,QAAL,CAAc,KAAK9B,KAAL,CAAWC,QAAX,CAAoBK,OAAlC,sBAA+D,YAAM;AACnE,aAAKnB,SAAL,GAAiB,OAAKa,KAAL,CAAWC,QAAX,CAAoBK,OAApB,CAA4BnB,SAA7C;AACA,aAAKK,UAAL,GAAkB,CAAC,CAAC,OAAKQ,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2B+B,GAA7B,IAAoC,OAAK9C,SAA3D;AACD,KAHD;;AAKA;AACA;AACA,SAAK2C,QAAL,CAAc,KAAK9B,KAAL,CAAWC,QAAX,CAAoBC,MAAlC,gBAAwD,YAAM;AAC5D,aAAKV,UAAL,GAAkB,CAAC,CAAC,OAAKQ,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2B+B,GAA7B,IAAoC,OAAK9C,SAA3D;AACD,KAFD;AAGD,GA3K8B;;;AA6K/B;;;;;;;;;AASA6C,eAtL+B,yBAsLjBD,KAtLiB,EAsLV;AACnB,QAAI,8BAAWA,KAAX,CAAJ,EAAuB;AACrB,WAAKhB,OAAL,kBAA8B,eAAKC,IAAL,CAAU;AACtCL,eAAOoB,MAAMtB,IAAN,CAAWE;AADoB,OAAV,EAE3B;AACDM,gBAAQ,KAAKjB;AADZ,OAF2B,CAA9B;AAKD;AACF,GA9L8B;;;AAgM/B;;;;;;;;;;;;AAYAkC,MA5M+B,gBA4M1BC,UA5M0B,EA4MdZ,OA5Mc,EA4ML;AACxB,QAAMa,OAAO,eAAKpB,IAAL,CAAU,EAAV,EAAc,EAACC,QAAQ,KAAKjB,KAAd,EAAd,CAAb;;AAEAoC,SAAKF,IAAL,CAAUC,UAAV,EAAsBZ,OAAtB;AACA,WAAOa,IAAP;AACD,GAjN8B;AAAA;AAAA,CAAnB,CAAd;;kBAoNepD,K","file":"phone.js","sourcesContent":["/**!\n *\n * Copyright (c) 2016-2017 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport {SparkPlugin} from '@ciscospark/spark-core';\nimport {defaults} from 'lodash';\nimport Call from './call';\nimport {shouldRing} from './state-parsers';\nimport {getUserMedia} from './webrtc';\n\n/**\n * Incoming Call Event\n *\n * Emitted when a call begins and when {@link Phone#register} is invoked and\n * there are active calls.\n *\n * @event call:incoming\n * @instance\n * @memberof Phone\n * @type {Object}\n * @property {Call} call The incoming call\n */\n\n/**\n * @class\n * @extends SparkPlugin\n */\nconst Phone = SparkPlugin.extend({\n  session: {\n    /**\n     * Indicates whether or not the WebSocket is connected\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    connected: {\n      default: false,\n      type: `boolean`\n    },\n    /**\n     * Specifies the facingMode to be used by {@link Phone#dial} and\n     * {@link Call#answer} when no constraint is specified. Does not apply if\n     * - a {@link MediaStream} is passed to {@link Phone#dial} or\n     * {@link Call#answer}\n     * - constraints are passed to {@link Phone#dial} or  {@link Call#answer}\n     * The only valid values are `user` and `environment`. For any other values,\n     * you must provide your own constrains or {@link MediaStream}\n     * @default `user`\n     * @instance\n     * @memberof Phone\n     * @type {string}\n     */\n    defaultFacingMode: {\n      default: `user`,\n      type: `string`,\n      values: [`user`, `environment`]\n    },\n    /**\n     * indicates whether or not the client is registered with the Cisco Spark\n     * cloud\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    registered: {\n      default: false,\n      type: `boolean`\n    }\n  },\n\n  namespace: `phone`,\n\n  /**\n   * Indicates if the current browser appears to support webrtc calling. Note:\n   * at this time, there's no way to determine if the current browser supports\n   * h264 without asking for camera permissions\n   * @instance\n   * @memberof Phone\n   * @returns {Promise<Boolean>}\n   */\n  isCallingSupported() {\n    return new Promise((resolve) => {\n      // I'm not thrilled by this, but detectrtc breaks the global namespace in\n      // a way that screws up the browserOnly/nodeOnly test helpers.\n      // eslint-disable-next-line global-require\n      const DetectRTC = require(`detectrtc`);\n      resolve(DetectRTC.isWebRTCSupported);\n    });\n  },\n\n  /**\n   * Registers the client with the Cisco Spark cloud and starts listening for\n   * WebSocket events.\n   *\n   * Subsequent calls refresh the device registration.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  register() {\n    // Ideally, we could call spark.refresh via spark-core, but it doesn't know\n    // about the wdm plugin, and all of the leaky abstractions I can think of\n    // seem risky.\n\n    return this.spark.internal.device.refresh()\n      .then(() => {\n        if (this.connected) {\n          return Promise.resolve();\n        }\n        return Promise.all([\n          this.spark.internal.mercury.when(`event:mercury.buffer_state`)\n            .then(([message]) => {\n              if (message.data.bufferState.locus === `UNKNOWN`) {\n                return this.spark.internal.locus.list();\n              }\n              return Promise.resolve();\n            })\n            .then((loci) => {\n              if (!loci) {\n                return;\n              }\n              // eslint-disable-next-line max-nested-callbacks\n              loci.forEach((locus) => {\n                this.trigger(`call:incoming`, Call.make({\n                  locus\n                }, {\n                  parent: this.spark\n                }));\n              });\n            }),\n          this.spark.internal.mercury.connect()\n        ]);\n      });\n  },\n\n  /**\n   * Disconnects from WebSocket and unregisters from the Cisco Spark cloud.\n   *\n   * Subsequent calls will be a noop.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  deregister() {\n    return this.spark.internal.mercury.disconnect()\n      .then(() => this.spark.internal.device.unregister());\n  },\n\n  /**\n   * Create a MediaStream to be used for video preview.\n   *\n   * Note: You must explicitly pass the resultant stream to {@link Call#answer()}\n   * or {@link Phone#dial()}\n   * @instance\n   * @memberof Phone\n   * @param {Object|MediaStreamConstraints} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @returns {Promise<MediaStream>}\n   */\n  createLocalMediaStream(options) {\n    options = options || {};\n    const constraints = options.constraints || options;\n    defaults(constraints, {\n      audio: true,\n      video: true\n    });\n\n    return getUserMedia(constraints);\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Phone\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {undefined}\n   */\n  initialize(...args) {\n    Reflect.apply(SparkPlugin.prototype.initialize, this, args);\n\n    this.listenTo(this.spark.internal.mercury, `event:locus`, (event) => this._onLocusEvent(event));\n\n    // Note: we need to manually wire up change:connected because derived props\n    // can't read through this.parent\n    this.listenTo(this.spark.internal.mercury, `change:connected`, () => {\n      this.connected = this.spark.internal.mercury.connected;\n      this.registered = !!this.spark.internal.device.url && this.connected;\n    });\n\n    // Note: we need to manually wire up change:url because derived props\n    // can't read through this.parent\n    this.listenTo(this.spark.internal.device, `change:url`, () => {\n      this.registered = !!this.spark.internal.device.url && this.connected;\n    });\n  },\n\n  /**\n   * Determines if the {@link call:incoming} event should be emitted for the\n   * specified {@link Types~MercuryEvent}\n   * @emits call:incoming\n   * @instance\n   * @memberof Phone\n   * @param {Types~MercuryEvent} event\n   * @returns {undefined}\n   */\n  _onLocusEvent(event) {\n    if (shouldRing(event)) {\n      this.trigger(`call:incoming`, Call.make({\n        locus: event.data.locus\n      }, {\n        parent: this.spark\n      }));\n    }\n  },\n\n  /**\n   * Place a call to the specified dialString. A dial string may be an email\n   * address or sip uri.\n   * @instance\n   * @memberof Phone\n   * @param {string} dialString\n   * @param {Object} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @param {MediaStream} options.localMediaStream if no stream is specified, a\n   * new one will be created based on options.constraints\n   * @returns {Call}\n   */\n  dial(dialString, options) {\n    const call = Call.make({}, {parent: this.spark});\n\n    call.dial(dialString, options);\n    return call;\n  }\n});\n\nexport default Phone;\n"]}