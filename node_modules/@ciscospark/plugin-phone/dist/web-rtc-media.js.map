{"version":3,"sources":["web-rtc-media.js"],"names":["sending","audio","start","stop","video","getRemoteMediaStatus","kind","pc","signalingState","streams","getRemoteStreams","length","res","reduce","areStreamsFlowing","stream","tracks","getTracks","filter","track","isTrackReceiving","readyState","ended","undefined","getLocalMediaStatus","getLocalStreams","isFlowing","isStreamFlowing","isFlowingForTracks","isTrackFlowing","enabled","WebRTCMedia","extend","props","default","type","audioConstraint","localMediaStream","offerToReceiveAudio","offerToReceiveVideo","receivingAudio","receivingVideo","remoteMediaStream","sendingAudio","sendingVideo","videoConstraint","session","answerSdp","offerSdp","peer","acceptAnswer","answer","then","set","trigger","createOffer","RTCPeerConnection","iceServers","ontrack","event","forEach","onended","e","emit","p","resolve","includes","sdp","bindNegotiationEvents","end","unset","initialize","args","prototype","mediaType","on","hasTrack","once","catch","reason","bound","onnegotiationneeded","key","value","options","attrs","k"],"mappings":"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","file":"web-rtc-media.js","sourcesContent":["import AmpState from 'ampersand-state';\n\nimport {debounce, isBoolean, isObject} from 'lodash';\n\nimport {\n  acceptAnswer,\n  addStream,\n  createOffer,\n  end,\n  ensureH264,\n  getUserMedia,\n  removeStream,\n  startSendingAudio,\n  startSendingVideo,\n  stopSendingAudio,\n  stopSendingVideo\n} from './webrtc';\n\n// at some point, this could potentially move into webrtc.js, but it gets the\n// job done for now.\nconst sending = {\n  audio: {\n    start: startSendingAudio,\n    stop: stopSendingAudio\n  },\n  video: {\n    start: startSendingVideo,\n    stop: stopSendingVideo\n  }\n};\n\n/**\n * Determines if the peer connection is receiving the specified kind of media\n * @param {string} kind audio|video\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {bool} true if receiving, false if not\n */\nfunction getRemoteMediaStatus(kind, pc) {\n  if (pc.signalingState === `closed`) {\n    return false;\n  }\n\n  const streams = pc.getRemoteStreams();\n\n  if (streams.length === 0) {\n    return false;\n  }\n\n  const res = streams.reduce((areStreamsFlowing, stream) => {\n    const tracks = stream.getTracks().filter((track) => track.kind === kind);\n\n    if (tracks.length === 0) {\n      return false;\n    }\n\n    return tracks.reduce((isTrackReceiving, track) => {\n      if (isTrackReceiving) {\n        return isTrackReceiving;\n      }\n\n      if (track.readyState === `ended`) {\n        return false;\n      }\n\n      if (track.ended) {\n        return false;\n      }\n\n      return true;\n    }, undefined);\n  }, undefined);\n\n  if (res) {\n    return res;\n  }\n\n  return false;\n}\n\n/**\n * Determines if the peer connection is sending the specified kind of media\n * @param {string} kind audio|video\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {bool} true if sending, false if not\n */\nfunction getLocalMediaStatus(kind, pc) {\n  const res = pc.getLocalStreams().reduce((isFlowing, stream) => {\n    const isStreamFlowing = stream.getTracks().reduce((isFlowingForTracks, track) => {\n      const isTrackFlowing = track.kind === kind && track.enabled;\n      return isFlowingForTracks || isTrackFlowing;\n    }, false);\n    return isFlowing || isStreamFlowing;\n  }, false);\n  return res;\n}\n\nconst WebRTCMedia = AmpState.extend({\n  props: {\n    audio: {\n      default: false,\n      type: `boolean`\n    },\n    audioConstraint: `any`,\n    ended: {\n      default: false,\n      type: `boolean`\n    },\n    localMediaStream: {\n      default: undefined,\n      type: `object`\n    },\n    offerToReceiveAudio: {\n      default: false,\n      type: `boolean`\n    },\n    offerToReceiveVideo: {\n      default: false,\n      type: `boolean`\n    },\n    receivingAudio: {\n      default: false,\n      type: `boolean`\n    },\n    receivingVideo: {\n      default: false,\n      type: `boolean`\n    },\n    remoteMediaStream: {\n      default: undefined,\n      type: `object`\n    },\n    sendingAudio: {\n      default: false,\n      type: `boolean`\n    },\n    sendingVideo: {\n      default: false,\n      type: `boolean`\n    },\n    video: {\n      default: false,\n      type: `boolean`\n    },\n    videoConstraint: `any`\n  },\n\n  session: {\n    answerSdp: `string`,\n    offerSdp: `string`,\n    peer: {\n      type: `object`\n    }\n  },\n\n  acceptAnswer(answer) {\n    return acceptAnswer(this.peer, answer)\n      .then(() => {\n        this.answerSdp = answer;\n        this.set({\n          sendingAudio: getLocalMediaStatus(`audio`, this.peer),\n          sendingVideo: getLocalMediaStatus(`video`, this.peer)\n        });\n      })\n      .then(() => this.trigger(`answeraccepted`));\n  },\n\n  createOffer() {\n    if (!this.peer) {\n      this.peer = new RTCPeerConnection({iceServers: []});\n\n      this.peer.ontrack = (event) => {\n        this.remoteMediaStream = event.streams[0];\n\n        this.remoteMediaStream.getTracks().forEach((track) => {\n          track.onended = () => {\n            try {\n              if (track.kind === `audio`) {\n                this.receivingAudio = getRemoteMediaStatus(`audio`, this.peer);\n              }\n              else {\n                this.receivingVideo = getRemoteMediaStatus(`video`, this.peer);\n              }\n            }\n            catch (e) {\n              this.emit(`error`, e);\n            }\n          };\n        });\n\n        this.receivingAudio = getRemoteMediaStatus(`audio`, this.peer);\n        this.receivingVideo = getRemoteMediaStatus(`video`, this.peer);\n      };\n    }\n\n    let p;\n    if (this.localMediaStream) {\n      p = Promise.resolve();\n    }\n    else if (this.audio || this.video) {\n      p = Promise.resolve(getUserMedia({\n        audio: this.audioConstraint,\n        video: this.videoConstraint\n      })\n        .then((stream) => {\n          this.localMediaStream = stream;\n        }));\n    }\n\n    return Promise.resolve(p)\n      .then(() => {\n        if (this.localMediaStream && !this.peer.getLocalStreams().includes(this.localMediaStream)) {\n          addStream(this.peer, this.localMediaStream);\n        }\n      })\n      .then(() => createOffer(this.peer, {\n        offerToReceiveAudio: this.offerToReceiveAudio,\n        offerToReceiveVideo: this.offerToReceiveVideo\n      }))\n      .then(ensureH264(this.video))\n      .then((sdp) => {\n        this.bindNegotiationEvents();\n        this.offerSdp = sdp;\n        return sdp;\n      });\n  },\n\n  end() {\n    if (!this.ended) {\n      if (this.peer && this.peer.signalingState !== `closed`) {\n        end(this.peer);\n      }\n      this.unset(`localMediaStream`);\n      this.unset(`remoteMediaStream`);\n      this.ended = true;\n    }\n  },\n\n  initialize(...args) {\n    Reflect.apply(AmpState.prototype.initialize, this, args);\n\n    [\n      `audio`,\n      `video`\n    ].forEach((mediaType) => {\n      this.on(`change:${mediaType}`, () => {\n        if (!this.peer) {\n          return;\n        }\n\n        let p;\n        if (this[mediaType]) {\n          const hasTrack = this.localMediaStream\n            .getTracks()\n            // I really don't see a more readable way to implement this\n            // eslint-disable-next-line max-nested-callbacks\n            .filter((track) => track.kind === mediaType)\n            .length;\n\n          if (hasTrack) {\n            p = sending[mediaType].start(this.peer);\n          }\n          else {\n            p = new Promise((resolve) => {\n              // I really don't see a more readable way to implement this\n              // eslint-disable-next-line max-nested-callbacks\n              this.once(`negotiationneeded`, () => {\n                this.once(`answeraccepted`, resolve);\n              });\n            });\n            sending[mediaType].start(this.peer);\n          }\n        }\n        else {\n          p = sending[mediaType].stop(this.peer);\n        }\n\n        Promise.resolve(p)\n          .then(() => {\n            this[mediaType === `audio` ? `sendingAudio` : `sendingVideo`] = getLocalMediaStatus(mediaType, this.peer);\n          })\n          .catch((reason) => {\n            this.emit(`error`, reason);\n          });\n      });\n\n    });\n\n    this.on(`change:localMediaStream`, () => {\n      if (!this.peer) {\n        return;\n      }\n\n      if (this.peer.signalingState === `closed`) {\n        return;\n      }\n\n      const streams = this.peer.getLocalStreams();\n      if (!streams.includes(this.localMediaStream)) {\n        streams.forEach((stream) => {\n          removeStream(this.peer, stream);\n        });\n        addStream(this.peer, this.localMediaStream);\n\n        const sendingAudio = getLocalMediaStatus(`audio`, this.peer);\n        const sendingVideo = getLocalMediaStatus(`video`, this.peer);\n        this.set({\n          sendingAudio,\n          audio: sendingAudio,\n          sendingVideo,\n          video: sendingVideo\n        });\n      }\n    });\n  },\n\n  /**\n   * Binds events that should be bound one time only once the session has been\n   * fully negotiated\n   * @private\n   * @returns {undefined}\n   */\n  bindNegotiationEvents() {\n    if (this.bound) {\n      return;\n    }\n    this.bound = true;\n\n    this.peer.onnegotiationneeded = debounce(() => {\n      this.emit(`negotiationneeded`);\n    });\n\n    this.on(`change:offerToReceiveAudio`, () => {\n      this.trigger(`negotiationneeded`);\n    });\n\n    this.on(`change:offerToReceiveVideo`, () => {\n      this.trigger(`negotiationneeded`);\n    });\n  },\n\n  set(key, value, options) {\n    let attrs;\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (isObject(key) || key === null) {\n      attrs = key;\n      options = value;\n    }\n    else {\n      attrs = {};\n      attrs[key] = value;\n    }\n\n    options = options || {};\n\n    Object.keys(attrs).forEach((k) => {\n      [`audio`, `video`].forEach((mediaType) => {\n        if (k === mediaType) {\n          if (isObject(attrs[k])) {\n            attrs[`${mediaType}Constraint`] = attrs[k];\n            attrs[k] = true;\n          }\n          else if (isBoolean(attrs[k])) {\n            attrs[`${mediaType}Constraint`] = attrs[k];\n          }\n        }\n      });\n    });\n\n    Reflect.apply(AmpState.prototype.set, this, [attrs, options]);\n  }\n\n});\n\nexport default WebRTCMedia;\n"]}