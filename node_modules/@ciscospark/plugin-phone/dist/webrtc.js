'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureH264 = exports.removeStream = exports.addStream = exports.end = exports.acceptAnswer = exports.createOffer = exports.stopSendingVideo = exports.stopSendingAudio = exports.startSendingVideo = exports.startSendingAudio = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

exports.getUserMedia = getUserMedia;
exports.mediaDirection = mediaDirection;

require('webrtc-adapter');

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _common = require('@ciscospark/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var startSendingMedia = (0, _curry3.default)(function (kind, pc) {
  var foundKind = false;
  pc.getLocalStreams().forEach(function (stream) {
    stream.getTracks().forEach(function (track) {
      if (track.kind === kind) {
        foundKind = true;
        track.enabled = true;
      }
    });
  });

  // If we didn't find any tracks for this stream/pc, we need to get new media
  if (!foundKind) {
    var constraints = {
      audio: kind === 'audio',
      video: kind === 'video'
    };

    return getUserMedia(constraints).then(function (stream) {
      var localStream = pc.getLocalStreams()[0];
      if (localStream) {
        if (pc.addTrack) {
          stream.getTracks().forEach(function (track) {
            if (localStream.addTrack) {
              localStream.addTrack(track);
            }
            if (stream.removeTrack) {
              stream.removeTrack(track);
            }
            pc.addTrack(track, localStream);
          });
        } else {
          stream.getTracks().forEach(function (track) {
            localStream.addTrack(track);
          });
        }

        // The next few lines are a silly hack to deal with chrome not
        // firing the negotiationneeded event when tracks get added to
        // streams. We'll just have to check periodically to see if this has
        // been fixed.
        if (pc.removeStream) {
          pc.removeStream(localStream);
          pc.addStream(localStream);
        }
      } else {
        addStream(pc, stream);
      }
    });
  }

  return _promise2.default.resolve();
}); /**!
     *
     * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
     * @private
     */

/* eslint max-nested-callbacks: [0] */

var stopSendingMedia = (0, _curry3.default)(function (kind, pc) {
  pc.getLocalStreams().forEach(function (stream) {
    stream.getTracks().forEach(function (track) {
      if (track.kind === kind) {
        track.enabled = false;
      }
    });
  });
});

/**
 * Adds a bandwith limit line to the sdp; without this line, calling fails
 * @param {string} sdp SDP
 * @private
 * @returns {string} The modified SDP
 */
function limitBandwith(sdp) {
  return sdp.split('\r\n').reduce(function (lines, line) {
    lines.push(line);
    if (line.startsWith('m=')) {
      lines.push('b=TIAS:' + (line.includes('audio') ? 64000 : 1000000));
    }
    return lines;
  }, []).join('\r\n');
}

/**
 * Ends all streams for the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc The RTCPeerConnection for which to end all
 * streams
 * @private
 * @returns {undefined}
 */
function endAllStreams(pc) {
  pc.getLocalStreams().forEach(stopStream);
  pc.getRemoteStreams().forEach(stopStream);
}

/**
 * Stops the specified stream's tracks and the stream (depending on browser
 * capabilities)
 * @param {MediaStream} stream The MediaStream to stop
 * @private
 * @returns {undefined}
 */
function stopStream(stream) {
  // need to reattach any removed tracks (even if they're stopped) to make sure
  // the camera gets turned off.
  if (stream.getTracks) {
    stream.getTracks().forEach(function (track) {
      return track.stop();
    });
  }

  if (stream.stop) {
    stream.stop();
  }
}

/**
 * Stops sending audio via the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop audio
 * @private
 * @returns {Promise}
 */
var startSendingAudio = exports.startSendingAudio = startSendingMedia('audio');
/**
 * Stops sending video via the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop video
 * @private
 * @returns {Promise}
 */
var startSendingVideo = exports.startSendingVideo = startSendingMedia('video');
/**
 * Starts sending audio via the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start audio
 * @private
 * @returns {Promise}
 */
var stopSendingAudio = exports.stopSendingAudio = stopSendingMedia('audio');
/**
 * Stops sending video via the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start video
 * @private
 * @returns {Promise}
 */
var stopSendingVideo = exports.stopSendingVideo = stopSendingMedia('video');

/**
 * Wrapper around navigator.mediaDevices.getUserMedia()
 * @param {MediaStreamConstraints} constraints if NODE_ENV is `test`, will
 * automatically add `{fake: true}`. If this is problematic for your use case,
 * you'll need to explicitly include `{fake: false}`
 * @private
 * @returns {Promise<MediaStream>} The resultant MediaStream
 */
function getUserMedia(constraints) {
  (0, _defaults3.default)(constraints, { fake: process.env.NODE_ENV === 'test' });
  return navigator.mediaDevices.getUserMedia(constraints);
}

/**
 * Creates an offer sdp based on the state of the specified RTCPeerConnection and
 * offer options
 * @param {RTCPeerConnection} pc
 * @param { RTCOfferOptions} offerOptions
 * @private
 * @returns {Promise<string>} Resolves with the offer sdp
 */
var createOffer = exports.createOffer = (0, _curry3.default)(function (pc, offerOptions) {
  offerOptions = offerOptions || {};
  (0, _defaults3.default)(offerOptions, {
    offerToReceiveVideo: true,
    offerToReceiveAudio: true
  });

  var promise = new _promise2.default(function (resolve) {
    pc.onicecandidate = function (event) {
      if (!event.candidate) {
        pc.onicecandidate = undefined;
        resolve();
      }
    };

    // Note: this timeout really shouldn't exist at all. There's a pending PR
    // some additional work to remove it entirely
    setTimeout(function () {
      pc.onicecandidate = undefined;
      resolve();
    }, 1500);
  });

  return pc.createOffer(offerOptions).then((0, _common.tap)(function (offer) {
    offer.sdp = limitBandwith(offer.sdp);
  })).then((0, _common.tap)(function (offer) {
    if (process.env.LOG_SDP) {
      // eslint-disable-next-line no-console
      console.info('offer', offer.sdp);
    }
  })).then(function (offer) {
    return pc.setLocalDescription(offer);
  }).then(function () {
    return _promise2.default.resolve(promise);
  })
  // Apparently chrome somehow moves the bandwith limit out of the video
  // section, so we need to reapply it.
  .then(function () {
    return limitBandwith(pc.localDescription.sdp);
  });
});

/**
 * Applies an incoming answer sdp to the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc
 * @param {string} sdp
 * @private
 * @returns {Promise}
 */
var acceptAnswer = exports.acceptAnswer = (0, _curry3.default)(function (pc, sdp) {
  if (process.env.LOG_SDP) {
    // eslint-disable-next-line no-console
    console.info('answer', sdp);
  }
  return pc.setRemoteDescription(new RTCSessionDescription({
    sdp: sdp,
    type: 'answer'
  }));
});

/**
 * Terminates the specified RTCPeerConnection
 * @param {RTCPeerConnection} pc
 * @private
 * @returns {undefined}
 */
var end = exports.end = (0, _curry3.default)(function (pc) {
  if (pc.signalingState !== 'closed') {
    endAllStreams(pc);
    pc.close();
  }
});

var curriedAddStream = (0, _curry3.default)(addStream);
var curriedRemoveStream = (0, _curry3.default)(removeStream);

/**
 * Adds the specified stream to the specified RTCPeerConnection
 * @name addStream
 * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream
 * @param {MediaStream} stream The stream to add
 * @private
 * @returns {undefined}
 */
exports.addStream = curriedAddStream;

/**
 * Removes the specified stream from the specified RTCPeerConnection
 * @name addStream
 * @param {PeerConnection} pc
 * @param {MediaStream} stream
 * @private
 * @returns {undefined}
 */

exports.removeStream = curriedRemoveStream;

/**
 * Adds the specified stream to the specified RTCPeerConnection
 * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream
 * @param {MediaStream} stream The stream to add
 * @private
 * @returns {undefined}
 */

function addStream(pc, stream) {
  if (pc.addTrack) {
    stream.getTracks().forEach(function (track) {
      return pc.addTrack(track, stream);
    });
  } else {
    pc.addStream(stream);
  }
}

/**
 * Removes the specified stream from the specified RTCPeerConnection
 * @param {PeerConnection} pc
 * @param {MediaStream} stream
 * @private
 * @returns {undefined}
 */
function removeStream(pc, stream) {
  if (pc.removeTrack && pc.getSenders) {
    var senders = pc.getSenders();
    stream.getTracks().forEach(function (track) {
      // Becuase why would `removeTrack` accept a MediaStreamTrack?
      pc.removeTrack(senders.find(function (sender) {
        return sender.track === track;
      }), stream);
    });
  } else {
    pc.removeStream(stream);
  }
}

/**
 * returns the direction line for the specified media type.
 * @param {string} type
 * @param {RTCPeerConnection} pc
 * @private
 * @returns {string}
 */
function mediaDirection(type, pc) {
  if (pc.connectionState === 'closed' || pc.signalingState === 'closed') {
    return 'inactive';
  }

  if (!pc.localDescription) {
    return 'inactive';
  }
  var sdp = _sdpTransform2.default.parse(pc.localDescription.sdp);
  var media = (0, _find3.default)(sdp.media, { type: type });
  if (!media) {
    return 'inactive';
  }

  if (type === 'audio' && media.direction === 'sendonly') {
    var remoteSdp = _sdpTransform2.default.parse(pc.remoteDescription.sdp);
    var remoteMedia = (0, _find3.default)(remoteSdp.media, { type: type });
    if (remoteMedia && remoteMedia.direction === 'inactive') {
      return 'inactive';
    }
  }

  return media.direction;
}

/**
 * Checks a given sdp to ensure it contains an offer for the h264 codec
 * @param {Boolean} wantsVideo
 * @param {String} offer
 * @private
 * @returns {String} returns the offer to simplify use in promise chains
 */
var ensureH264 = exports.ensureH264 = (0, _curry3.default)(function (wantsVideo, offer) {
  if (wantsVideo) {
    if (!offer.includes('m=video')) {
      throw new Error('No video section found in offer');
    }
    if (!/[hH]264/.test(offer)) {
      throw new Error('Offer does not include h264 codec');
    }
  }
  return offer;
});