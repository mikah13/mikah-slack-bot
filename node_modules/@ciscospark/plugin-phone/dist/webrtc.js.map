{"version":3,"sources":["webrtc.js"],"names":["getUserMedia","mediaDirection","startSendingMedia","kind","pc","foundKind","getLocalStreams","forEach","stream","getTracks","track","enabled","constraints","audio","video","then","localStream","addTrack","removeTrack","removeStream","addStream","resolve","stopSendingMedia","limitBandwith","sdp","split","reduce","lines","line","push","startsWith","includes","join","endAllStreams","stopStream","getRemoteStreams","stop","startSendingAudio","startSendingVideo","stopSendingAudio","stopSendingVideo","fake","process","env","NODE_ENV","navigator","mediaDevices","createOffer","offerOptions","offerToReceiveVideo","offerToReceiveAudio","promise","onicecandidate","event","candidate","undefined","setTimeout","offer","LOG_SDP","console","info","setLocalDescription","localDescription","acceptAnswer","setRemoteDescription","RTCSessionDescription","type","end","signalingState","close","curriedAddStream","curriedRemoveStream","getSenders","senders","find","sender","connectionState","parse","media","direction","remoteSdp","remoteDescription","remoteMedia","ensureH264","wantsVideo","Error","test"],"mappings":"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","file":"webrtc.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\n/* eslint max-nested-callbacks: [0] */\n\nimport 'webrtc-adapter';\nimport transform from 'sdp-transform';\nimport {curry, defaults, find} from 'lodash';\nimport {tap} from '@ciscospark/common';\n\nconst startSendingMedia = curry((kind, pc) => {\n  let foundKind = false;\n  pc.getLocalStreams().forEach((stream) => {\n    stream.getTracks().forEach((track) => {\n      if (track.kind === kind) {\n        foundKind = true;\n        track.enabled = true;\n      }\n    });\n  });\n\n  // If we didn't find any tracks for this stream/pc, we need to get new media\n  if (!foundKind) {\n    const constraints = {\n      audio: kind === `audio`,\n      video: kind === `video`\n    };\n\n    return getUserMedia(constraints)\n      .then((stream) => {\n        const localStream = pc.getLocalStreams()[0];\n        if (localStream) {\n          if (pc.addTrack) {\n            stream.getTracks().forEach((track) => {\n              if (localStream.addTrack) {\n                localStream.addTrack(track);\n              }\n              if (stream.removeTrack) {\n                stream.removeTrack(track);\n              }\n              pc.addTrack(track, localStream);\n            });\n          }\n          else {\n            stream.getTracks().forEach((track) => {\n              localStream.addTrack(track);\n            });\n          }\n\n          // The next few lines are a silly hack to deal with chrome not\n          // firing the negotiationneeded event when tracks get added to\n          // streams. We'll just have to check periodically to see if this has\n          // been fixed.\n          if (pc.removeStream) {\n            pc.removeStream(localStream);\n            pc.addStream(localStream);\n          }\n        }\n        else {\n          addStream(pc, stream);\n        }\n      });\n  }\n\n  return Promise.resolve();\n});\n\nconst stopSendingMedia = curry((kind, pc) => {\n  pc.getLocalStreams().forEach((stream) => {\n    stream.getTracks().forEach((track) => {\n      if (track.kind === kind) {\n        track.enabled = false;\n      }\n    });\n  });\n});\n\n/**\n * Adds a bandwith limit line to the sdp; without this line, calling fails\n * @param {string} sdp SDP\n * @private\n * @returns {string} The modified SDP\n */\nfunction limitBandwith(sdp) {\n  return sdp.split(`\\r\\n`).reduce((lines, line) => {\n    lines.push(line);\n    if (line.startsWith(`m=`)) {\n      lines.push(`b=TIAS:${line.includes(`audio`) ? 64000 : 1000000}`);\n    }\n    return lines;\n  }, []).join(`\\r\\n`);\n}\n\n/**\n * Ends all streams for the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to end all\n * streams\n * @private\n * @returns {undefined}\n */\nfunction endAllStreams(pc) {\n  pc.getLocalStreams().forEach(stopStream);\n  pc.getRemoteStreams().forEach(stopStream);\n}\n\n/**\n * Stops the specified stream's tracks and the stream (depending on browser\n * capabilities)\n * @param {MediaStream} stream The MediaStream to stop\n * @private\n * @returns {undefined}\n */\nfunction stopStream(stream) {\n  // need to reattach any removed tracks (even if they're stopped) to make sure\n  // the camera gets turned off.\n  if (stream.getTracks) {\n    stream.getTracks().forEach((track) => track.stop());\n  }\n\n  if (stream.stop) {\n    stream.stop();\n  }\n}\n\n/**\n * Stops sending audio via the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop audio\n * @private\n * @returns {Promise}\n */\nexport const startSendingAudio = startSendingMedia(`audio`);\n/**\n * Stops sending video via the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop video\n * @private\n * @returns {Promise}\n */\nexport const startSendingVideo = startSendingMedia(`video`);\n/**\n * Starts sending audio via the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start audio\n * @private\n * @returns {Promise}\n */\nexport const stopSendingAudio = stopSendingMedia(`audio`);\n/**\n * Stops sending video via the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start video\n * @private\n * @returns {Promise}\n */\nexport const stopSendingVideo = stopSendingMedia(`video`);\n\n/**\n * Wrapper around navigator.mediaDevices.getUserMedia()\n * @param {MediaStreamConstraints} constraints if NODE_ENV is `test`, will\n * automatically add `{fake: true}`. If this is problematic for your use case,\n * you'll need to explicitly include `{fake: false}`\n * @private\n * @returns {Promise<MediaStream>} The resultant MediaStream\n */\nexport function getUserMedia(constraints) {\n  defaults(constraints, {fake: process.env.NODE_ENV === `test`});\n  return navigator.mediaDevices.getUserMedia(constraints);\n}\n\n/**\n * Creates an offer sdp based on the state of the specified RTCPeerConnection and\n * offer options\n * @param {RTCPeerConnection} pc\n * @param { RTCOfferOptions} offerOptions\n * @private\n * @returns {Promise<string>} Resolves with the offer sdp\n */\nexport const createOffer = curry((pc, offerOptions) => {\n  offerOptions = offerOptions || {};\n  defaults(offerOptions, {\n    offerToReceiveVideo: true,\n    offerToReceiveAudio: true\n  });\n\n  const promise = new Promise((resolve) => {\n    pc.onicecandidate = (event) => {\n      if (!event.candidate) {\n        pc.onicecandidate = undefined;\n        resolve();\n      }\n    };\n\n    // Note: this timeout really shouldn't exist at all. There's a pending PR\n    // some additional work to remove it entirely\n    setTimeout(() => {\n      pc.onicecandidate = undefined;\n      resolve();\n    }, 1500);\n\n  });\n\n  return pc.createOffer(offerOptions)\n    .then(tap((offer) => {offer.sdp = limitBandwith(offer.sdp);}))\n    .then(tap((offer) => {\n      if (process.env.LOG_SDP) {\n        // eslint-disable-next-line no-console\n        console.info(`offer`, offer.sdp);\n      }\n    }))\n    .then((offer) => pc.setLocalDescription(offer))\n    .then(() => Promise.resolve(promise))\n    // Apparently chrome somehow moves the bandwith limit out of the video\n    // section, so we need to reapply it.\n    .then(() => limitBandwith(pc.localDescription.sdp));\n});\n\n/**\n * Applies an incoming answer sdp to the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc\n * @param {string} sdp\n * @private\n * @returns {Promise}\n */\nexport const acceptAnswer = curry((pc, sdp) => {\n  if (process.env.LOG_SDP) {\n    // eslint-disable-next-line no-console\n    console.info(`answer`, sdp);\n  }\n  return pc.setRemoteDescription(new RTCSessionDescription({\n    sdp,\n    type: `answer`\n  }));\n});\n\n/**\n * Terminates the specified RTCPeerConnection\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {undefined}\n */\nexport const end = curry((pc) => {\n  if (pc.signalingState !== `closed`) {\n    endAllStreams(pc);\n    pc.close();\n  }\n});\n\nconst curriedAddStream = curry(addStream);\nconst curriedRemoveStream = curry(removeStream);\n\n/**\n * Adds the specified stream to the specified RTCPeerConnection\n * @name addStream\n * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream\n * @param {MediaStream} stream The stream to add\n * @private\n * @returns {undefined}\n */\nexport {curriedAddStream as addStream};\n\n/**\n * Removes the specified stream from the specified RTCPeerConnection\n * @name addStream\n * @param {PeerConnection} pc\n * @param {MediaStream} stream\n * @private\n * @returns {undefined}\n */\n\nexport {curriedRemoveStream as removeStream};\n\n/**\n * Adds the specified stream to the specified RTCPeerConnection\n * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream\n * @param {MediaStream} stream The stream to add\n * @private\n * @returns {undefined}\n */\nfunction addStream(pc, stream) {\n  if (pc.addTrack) {\n    stream.getTracks().forEach((track) => pc.addTrack(track, stream));\n  }\n  else {\n    pc.addStream(stream);\n  }\n}\n\n/**\n * Removes the specified stream from the specified RTCPeerConnection\n * @param {PeerConnection} pc\n * @param {MediaStream} stream\n * @private\n * @returns {undefined}\n */\nfunction removeStream(pc, stream) {\n  if (pc.removeTrack && pc.getSenders) {\n    const senders = pc.getSenders();\n    stream.getTracks().forEach((track) => {\n      // Becuase why would `removeTrack` accept a MediaStreamTrack?\n      pc.removeTrack(senders.find((sender) => sender.track === track), stream);\n    });\n  }\n  else {\n    pc.removeStream(stream);\n  }\n}\n\n/**\n * returns the direction line for the specified media type.\n * @param {string} type\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {string}\n */\nexport function mediaDirection(type, pc) {\n  if (pc.connectionState === `closed` || pc.signalingState === `closed`) {\n    return `inactive`;\n  }\n\n  if (!pc.localDescription) {\n    return `inactive`;\n  }\n  const sdp = transform.parse(pc.localDescription.sdp);\n  const media = find(sdp.media, {type});\n  if (!media) {\n    return `inactive`;\n  }\n\n  if (type === `audio` && media.direction === `sendonly`) {\n    const remoteSdp = transform.parse(pc.remoteDescription.sdp);\n    const remoteMedia = find(remoteSdp.media, {type});\n    if (remoteMedia && remoteMedia.direction === `inactive`) {\n      return `inactive`;\n    }\n  }\n\n  return media.direction;\n}\n\n/**\n * Checks a given sdp to ensure it contains an offer for the h264 codec\n * @param {Boolean} wantsVideo\n * @param {String} offer\n * @private\n * @returns {String} returns the offer to simplify use in promise chains\n */\nexport const ensureH264 = curry((wantsVideo, offer) => {\n  if (wantsVideo) {\n    if (!offer.includes(`m=video`)) {\n      throw new Error(`No video section found in offer`);\n    }\n    if (!/[hH]264/.test(offer)) {\n      throw new Error(`Offer does not include h264 codec`);\n    }\n  }\n  return offer;\n});\n"]}