'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _dec, _dec2, _desc, _value, _obj; /**!
                                       *
                                       * Copyright (c) 2016-2017 Cisco Systems, Inc. See LICENSE file.
                                       * @private
                                       */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _internalPluginLocus = require('@ciscospark/internal-plugin-locus');

var _stateParsers = require('./state-parsers');

var _boolToStatus = require('./bool-to-status');

var _boolToStatus2 = _interopRequireDefault(_boolToStatus);

var _webRtcMedia = require('./web-rtc-media');

var _webRtcMedia2 = _interopRequireDefault(_webRtcMedia);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _sdpTransform = require('sdp-transform');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @event ringing
 * @instance
 * @memberof Call
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} Types~Feedback
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 * @extends SparkPlugin
 */
var Call = _sparkCore.SparkPlugin.extend((_dec = (0, _common.whileInFlight)('locusJoinInFlight'), _dec2 = (0, _common.whileInFlight)('locusLeaveInFlight'), (_obj = {
  namespace: 'Phone',

  children: {
    media: _webRtcMedia2.default
  },

  session: {
    correlationId: 'string',
    /**
     * @instance
     * @memberof Call
     * @type {string}
     * @readonly
     */
    facingMode: {
      type: 'string',
      values: ['user', 'environment']
    },
    locus: 'object',
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: 'object',

    locusJoinInFlight: {
      default: false,
      type: 'boolean'
    },
    locusLeaveInFlight: {
      default: false,
      type: 'boolean'
    }
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && this.locus.url;
      }
    },
    isActive: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.isActive)(this.locus);
      }
    },
    activeParticipants: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.activeParticipants)(this.locus);
      }
    },
    activeParticipantsCount: {
      deps: ['activeParticipants'],
      fn: function fn() {
        return this.activeParticipants.length;
      }
    },
    joined: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joined)(this.locus);
      }
    },
    joinedOnThisDevice: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joinedOnThisDevice)(this.spark, this.locus);
      }
    },
    locusUrl: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus.url;
      }
    },
    device: {
      deps: ['locus'],
      fn: function fn() {
        var _this = this;

        return this.locus.self && (0, _find3.default)(this.locus.self.devices, function (item) {
          return item.url === _this.spark.internal.device.url;
        });
      }
    },
    mediaConnection: {
      deps: ['device'],
      fn: function fn() {
        return this.device && this.device.mediaConnections && this.device.mediaConnections[0];
      }
    },
    mediaId: {
      deps: ['mediaConnection'],
      fn: function fn() {
        return this.mediaConnection && this.mediaConnection.mediaId;
      }
    },
    remoteAudioMuted: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.remoteAudioMuted)((0, _stateParsers.remoteParticipant)(this.locus));
      }
    },
    remoteVideoMuted: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.remoteVideoMuted)((0, _stateParsers.remoteParticipant)(this.locus));
      }
    },
    direction: {
      deps: ['locus'],
      fn: function fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return 'out';
        }
        return (0, _stateParsers.direction)(this.locus);
      }
    },
    from: {
      deps: ['memberships'],
      fn: function fn() {
        return this.memberships.find(function (m) {
          return m.isInitiator;
        });
      }
    },
    to: {
      deps: ['memberships'],
      fn: function fn() {
        return this.memberships.find(function (m) {
          return !m.isInitiator;
        });
      }
    },
    local: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && this.locus.self;
      }
    },
    remote: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.remoteParticipant)(this.locus);
      }
    },
    memberships: {
      deps: ['locus'],
      fn: function fn() {
        var _this2 = this;

        return this.locus.participants.filter(function (participant) {
          return participant.type === 'USER';
        }).map(function (participant) {
          return {
            personId: _this2.spark.people.inferPersonIdFromUuid(participant.person.id),
            isInitiator: _this2.direction === 'out' ? participant.url === _this2.locus.self.url : participant.url !== _this2.locus.self.url,
            state: participant.state && participant.state.toLowerCase()
          };
        });
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.getState)(this.spark, this.locus);
      }
    },
    /**
     * Access to the remote partyâ€™s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: ['media.remoteMediaStream'],
      fn: function fn() {
        return this.media.remoteMediaStream;
      }
    },
    receivingAudio: {
      deps: ['media.receivingAudio'],
      fn: function fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: ['media.receivingVideo'],
      fn: function fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: ['media.sendingAudio'],
      fn: function fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: ['media.sendingVideo'],
      fn: function fn() {
        return this.media.sendingVideo;
      }
    }
  },

  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge: function acknowledge() {
    var _this3 = this;

    this.logger.info('call: acknowledging');
    return this.spark.internal.locus.alert(this.locus).then(function (locus) {
      return _this3._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this3.logger.info('call: acknowledged');
    }));
  },

  /**
   * Answers an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a noop
   * @instance
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer: function answer(options) {
    var _this4 = this;

    this.logger.info('call: answering');
    if (!this.locus || this.direction === 'out') {
      this.logger.info('call: outbound call, answer() is a noop');
      return _promise2.default.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    if (this.joinedOnThisDevice && this.media.peer) {
      this.logger.info('call: already joined on this device');
      return _promise2.default.resolve();
    }
    return this._join('join', this.locus, options).then((0, _common.tap)(function () {
      return _this4.logger.info('call: answered');
    }));
  },


  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline: function decline() {
    return this.reject();
  },

  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial: function dial(invitee, options) {
    var _this5 = this;

    this.locusJoinInFlight = true;
    this.logger.info('call: dialing');

    if (_common.base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      var parsed = _common.base64.decode(invitee).split('/');
      var resourceType = parsed[3];
      var id = parsed[4];
      if (resourceType === 'PEOPLE') {
        invitee = id;
      }
    }

    this.logger.info(this.registered, !!this.spark.internal.device.url, this.connected, this.spark.internal.mercury.connected, this.spark.internal.device.url);

    // Note: mercury.connect() will call device.register() if needed. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.internal.mercury.connect().then(function () {
      return _this5._join('create', invitee, options);
    }).then((0, _common.tap)(function () {
      return _this5.logger.info('call: dialed');
    })).catch(function (reason) {
      _this5.trigger('error', reason);
    }).then(function () {
      _this5.locusJoinInFlight = false;
    });

    return this;
  },


  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup: function hangup() {
    var _this6 = this;

    // Note: not a @oneFlight because this function must call itself
    if (this.direction === 'in' && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info('call: hanging up');

    this.media.end();

    if (this.locusJoinInFlight) {
      this.logger.info('call: locus join in flight, waiting for rest call to complete before hanging up');
      return this.when('change:locusJoinInFlight').then(function () {
        return _this6.hangup();
      });
    }

    if (!this.locus) {
      this.stopListening(this.spark.internal.mercury);
      this.off();
      this.logger.info('call: hang up complete, call never created');
      return _promise2.default.resolve();
    }

    return this._hangup();
  },


  /**
   * Initializer
   * @instance
   * @memberof Call
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this7 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.spark.internal.mercury, 'event:locus', function (event) {
      return _this7._onLocusEvent(event);
    });
    this.listenTo(this.media, 'error', function (error) {
      return _this7.trigger('error', error);
    });
    this.on('disconnected', function () {
      // need to do this on next tick otherwise this.off() prevents remaining
      // events from being received (e.g. other listeners for `disconnected`
      // won't execute)
      process.nextTick(function () {
        _this7.stopListening(_this7.spark.internal.mercury);
        _this7.off();
      });
    });

    this.listenTo(this.media, 'negotiationneeded', (0, _debounce3.default)(function () {
      _this7.media.createOffer().then(function () {
        return _this7._updateMedia({
          sdp: _this7.media.offerSdp,
          mediaId: _this7.mediaId
        });
      }).then(function () {
        return _this7._pollForExpectedLocus();
      }).then(function () {
        var sdp = JSON.parse(_this7.mediaConnection.remoteSdp).sdp;
        return _this7.media.acceptAnswer(sdp);
      }).catch(function (reason) {
        return _this7.emit('error', reason);
      });
    }));

    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on('change:media.localMediaStream', function () {
      _this7.localMediaStream = _this7.media.localMediaStream;
    });

    this.on('change:localMediaStream', function () {
      if (_this7.media.localMediaStream !== _this7.localMediaStream) {
        _this7.media.localMediaStream = _this7.localMediaStream;
      }

      if (_this7.facingMode) {
        var mode = (0, _get3.default)(_this7, 'media.videoConstraint.facingMode.ideal', (0, _get3.default)(_this7, 'media.videoConstraint.facingMode.ideal'));

        if (mode === 'user') {
          _this7.facingMode = 'user';
        }

        if (mode === 'environment') {
          _this7.facingMode = 'environment';
        }
      }
    });

    ['remoteMediaStream', 'localMediaStream', 'remoteAudioMuted', 'remoteVideoMuted'].forEach(function (key) {
      _this7.on('change:' + key, function () {
        return _this7.trigger(key + ':change');
      });
    });

    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on('change:isActive', function () {
      if (!_this7.isActive) {
        if (_this7.joinedOnThisDevice) {
          _this7.logger.info('call: hanging up due to locus going inactive');
          _this7.hangup();
        }
      }
    });

    this.on('change:activeParticipantsCount', function () {
      var previousLocus = _this7.previousAttributes().locus;
      if (_this7.joinedOnThisDevice && _this7.activeParticipantsCount === 1 && previousLocus && (0, _stateParsers.activeParticipants)(previousLocus).length > 1) {
        _this7.logger.info('call: hanging up due to last participant in call');
        _this7.hangup();
      }
    });

    this.on('change:status', function () {
      process.nextTick(function () {
        return _this7.trigger(_this7.status);
      });
    });
  },

  /**
   * Rejects an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a no-op.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  reject: function reject() {
    var _this8 = this;

    if (this.direction === 'out') {
      return _promise2.default.resolve();
    }

    this.logger.info('call: rejecting');
    /* eslint no-invalid-this: [0] */
    return this.spark.internal.locus.decline(this.locus).then(function (locus) {
      return _this8._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this8.stopListening(_this8.spark.internal.mercury);
    })).then((0, _common.tap)(function () {
      return _this8.off();
    })).then((0, _common.tap)(function () {
      return _this8.logger.info('call: rejected');
    }));
  },


  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {Types~Feedback} feedback
   * @returns {Promise}
   */
  sendFeedback: function sendFeedback(feedback) {
    return this.spark.internal.metrics.submit('meetup_call_user_rating', feedback);
  },
  startReceivingAudio: function startReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', true);
  },
  startReceivingVideo: function startReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', true);
  },


  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio: function startSendingAudio() {
    return this._changeSendingMedia('audio', true);
  },


  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo: function startSendingVideo() {
    return this._changeSendingMedia('video', true);
  },
  stopReceivingAudio: function stopReceivingAudio() {
    return this._changeReceivingMedia('offerToReceiveAudio', false);
  },
  stopReceivingVideo: function stopReceivingVideo() {
    return this._changeReceivingMedia('offerToReceiveVideo', false);
  },


  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio: function stopSendingAudio() {
    return this._changeSendingMedia('audio', false);
  },


  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo: function stopSendingVideo() {
    return this._changeSendingMedia('video', false);
  },


  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @instance
   * @memberof Call
   * @returns {undefined}
   */
  toggleFacingMode: function toggleFacingMode() {
    var _this9 = this;

    var constraints = {
      audio: (0, _assign2.default)({}, this.media.audioConstraint),
      video: this.media.videoConstraint
    };

    if (!constraints.video) {
      throw new Error('Cannot toggle facignMode on audio-only call');
    }

    if (this.facingMode !== 'user' && this.facingMode !== 'environment') {
      throw new Error('Cannot determine current facing mode; specify a new localMediaStream to change cameras');
    }

    if (constraints.video === true) {
      constraints.video = {
        facingMode: {
          ideal: this.facingMode
        }
      };
    }

    if (this.facingMode === 'user') {
      (0, _set3.default)(constraints, 'video.facingMode.ideal', 'environment');
    } else {
      (0, _set3.default)(constraints, 'video.facingMode.ideal', 'user');
    }

    return this.spark.phone.createLocalMediaStream(constraints).then(function (stream) {
      return new _promise2.default(function (resolve) {
        _this9.media.once('answeraccepted', resolve);
        _this9.localMediaStream = stream;
      });
    }).then(function () {
      _this9.facingMode = constraints.video.facingMode.ideal || constraints.video.facingMode.exact;
    });
  },


  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio: function toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },


  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo: function toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },


  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio: function toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },


  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo: function toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },
  _changeReceivingMedia: function _changeReceivingMedia(key, value) {
    var _this10 = this;

    return new _promise2.default(function (resolve) {
      _this10.once('change:receiving' + (key === 'offerToReceiveAudio' ? 'Audio' : 'Video'), function () {
        return resolve();
      });
      _this10.media.set(key, value);
    });
  },
  _changeSendingMedia: function _changeSendingMedia(key, value) {
    var _this11 = this;

    return new _promise2.default(function (resolve) {
      var sdp = (0, _sdpTransform.parse)(_this11.media.offerSdp);
      var section = (0, _find3.default)(sdp.media, { type: key });
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes('send')) {
        _this11.media.once('answeraccepted', resolve);
      } else {
        _this11.once('change:sending' + (key === 'audio' ? 'Audio' : 'Video'), function () {
          return resolve(_this11._updateSendingMedia());
        });
      }
      _this11.media.set(key, value);
    });
  },

  /**
   * Does the internal work necessary to end a call while allowing hangup() to
   * call itself without getting stuck in promise change because of oneFlight
   * @private
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  _hangup: function _hangup() {
    var _this12 = this;

    return this.spark.internal.locus.leave(this.locus).then(function (locus) {
      return _this12._setLocus(locus);
    })
    // Note: not stopping event-listening here; that'll happening
    // automatically when `disconnected` fires.
    .then((0, _common.tap)(function () {
      return _this12.logger.info('call: hung up');
    }));
  },

  // The complexity in _join is largely driven up by fairly readable `||`s
  // eslint-disable-next-line complexity
  _join: function _join(locusMethodName, target) {
    var _this13 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


    if (options.localMediaStream) {
      this.media.set('localMediaStream', options.localMediaStream);
    } else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              ideal: this.spark.phone.defaultFacingMode
            }
          }
        };
      }
      var mode = (0, _get3.default)(options, 'constraints.video.facingMode.ideal', (0, _get3.default)(options, 'constraints.video.facingMode.exact'));
      if (mode === 'user' || mode === 'environment') {
        this.facingMode = mode;
      }

      var recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = (0, _defaults3.default)(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });
    }

    var mediaOptions = {};
    if (options.constraints) {
      mediaOptions.audio = options.constraints.audio;
      mediaOptions.video = options.constraints.video;
    }

    if (options.offerOptions) {
      mediaOptions.offerToReceiveAudio = options.offerOptions.offerToReceiveAudio;
      mediaOptions.offerToReceiveVideo = options.offerOptions.offerToReceiveVideo;
    }

    if (mediaOptions.offerOptions || options.constraints) {
      this.media.set(mediaOptions);
    }

    if (!target.correlationId) {
      this.correlationId = options.correlationId = _uuid2.default.v4();
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    return this.media.createOffer().then(function () {
      return _this13.spark.internal.locus[locusMethodName](target, {
        localSdp: _this13.media.offerSdp,
        correlationId: _this13.correlationId
      });
    }).then(function (locus) {
      _this13._setLocus(locus);
      var answer = JSON.parse(_this13.mediaConnection.remoteSdp).sdp;
      _this13.logger.info('accepting offer');
      _this13.logger.info('peer state', _this13.media.peer && _this13.media.peer.signalingState);
      if (!_this13.media.ended) {
        return _this13.media.acceptAnswer(answer).then(function () {
          return _this13.logger.info('offer accepted');
        });
      }
      _this13.logger.info('call: already ended, not accepting answer');
      return _promise2.default.resolve();
    });
  },


  /**
   * Handles an incoming mercury event if relevant to this call.
   * @instance
   * @memberof Call
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  _onLocusEvent: function _onLocusEvent(event) {
    var _this14 = this;

    var device = (0, _find3.default)(event.data.locus.self.devices, function (item) {
      return item.url === _this14.spark.internal.device.url;
    });
    if (this.locus && event.data.locus.url === this.locus.url || this.correlationId && this.correlationId === device.correlationId) {
      this.logger.info('locus event: ' + event.data.eventType);
      this._setLocus(event.data.locus);
    }
  },

  /**
   * The response to a PUT to LOCUS/media may not be fully up-to-date when we
   * receive it. This method polls locus until we get a locus with the status
   * properties we expect (or three errors occur)
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise<Types~Locus>}
   */
  _pollForExpectedLocus: function _pollForExpectedLocus() {
    var _this15 = this;

    return new _promise2.default(function (resolve) {
      try {
        _this15._validateLocusMediaState(_this15.locus);
        resolve();
      } catch (err) {
        _this15.logger.warn('locus: received locus does not contain expected state; fetching again');
        resolve(_this15.spark.internal.locus.get(_this15.locus).then(function (locus) {
          return _this15._setLocus(locus);
        }).then(function () {
          return _this15._validateLocusMediaState(_this15.locus);
        }));
      }
    });
  },


  /**
   * Assigns a new locus to this.locus according to locus sequencing rules
   * @instance
   * @memberof Call
   * @param {Types~Locus} incoming
   * @private
   * @returns {Promise}
   */
  _setLocus: function _setLocus(incoming) {
    var _this16 = this;

    var current = this.locus;
    if (!current) {
      this.locus = incoming;
      return _promise2.default.resolve();
    }
    var action = this.spark.internal.locus.compare(current, incoming);

    switch (action) {
      case _internalPluginLocus.USE_INCOMING:
        this.locus = incoming;
        // certain reasons for setting a locus (such as from calling
        // acknowledge())
        if (this.device) {
          this.correlationId = this.device.correlationId;
        }
        break;
      case _internalPluginLocus.FETCH:
        return this.spark.internal.locus.get(current).then(function (locus) {
          return _this16._setLocus(locus);
        });
      default:
      // do nothing
    }

    return _promise2.default.resolve();
  },


  /**
   * Changes the status of media
   * @instance
   * @memberof Call
   * @param {Object} payload
   * @private
   * @returns {Promise}
   */
  _updateMedia: function _updateMedia(payload) {
    var _this17 = this;

    if (payload.sdp && !payload.sdp.includes('b=')) {
      throw new Error('outbound sdp should always have a \'b=\' line');
    }
    return this.spark.internal.locus.updateMedia(this.locus, payload).then(function (locus) {
      return _this17._setLocus(locus);
    });
  },

  /**
   * Changes the status of outbound media
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _updateSendingMedia: function _updateSendingMedia() {
    var _this18 = this;

    return this._updateMedia({
      sdp: this.media.offerSdp,
      mediaId: this.mediaId,
      audioMuted: !this.sendingAudio,
      videoMuted: !this.sendingVideo
    }).then(function () {
      return _this18._waitForExpectedLocus();
    });
  },


  /**
   * Checks that this.locus has the expected state
   * @instance
   * @memberof Call
   * @param {Types~Locus} locus
   * @private
   * @returns {Promise}
   */
  _validateLocusMediaState: function _validateLocusMediaState(locus) {
    var locusAudio = locus.self.status.audioStatus.toLowerCase();
    var mediaAudio = (0, _boolToStatus2.default)(this.media.audio, this.media.offerToReceiveAudio);
    if (locusAudio !== mediaAudio) {
      this.logger.warn('locus: expected audio ' + locusAudio + ' (locus) to equal ' + mediaAudio + ' (local media)');
      throw new Error('locus.self.status.audioStatus indicates the received DTO is out of date');
    }

    var locusVideo = locus.self.status.videoStatus.toLowerCase();
    var mediaVideo = (0, _boolToStatus2.default)(this.media.video, this.media.offerToReceiveVideo);
    if (locusVideo !== mediaVideo) {
      this.logger.warn('locus: expected video ' + locusVideo + ' (locus) to equal ' + mediaVideo + ' (local media)');
      throw new Error('locus.self.status.videoStatus indicates the received DTO is out of date');
    }

    return locus;
  },


  /**
   * Waits until this.locus describes the expected state
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _waitForExpectedLocus: function _waitForExpectedLocus() {
    var _this19 = this;

    return new _promise2.default(function (resolve) {
      var listener = function listener() {
        try {
          _this19._validateLocusMediaState(_this19.locus);
          _this19.off('change:locus', listener);
          resolve();
        } catch (err) {
          _this19.logger.warn('locus: current locus not in expected state; waiting for next locus');
        }
      };
      _this19.on('change:locus', listener);
      listener();
    });
  },
  version: '1.8.0'
}, (_applyDecoratedDescriptor(_obj, 'acknowledge', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'acknowledge'), _obj), _applyDecoratedDescriptor(_obj, 'answer', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'answer'), _obj), _applyDecoratedDescriptor(_obj, 'dial', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'dial'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, '_hangup', [_common.oneFlight, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, '_hangup'), _obj), _applyDecoratedDescriptor(_obj, '_join', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_join'), _obj), _applyDecoratedDescriptor(_obj, '_pollForExpectedLocus', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, '_pollForExpectedLocus'), _obj), _applyDecoratedDescriptor(_obj, '_updateSendingMedia', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_updateSendingMedia'), _obj)), _obj)));

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

exports.default = Call;