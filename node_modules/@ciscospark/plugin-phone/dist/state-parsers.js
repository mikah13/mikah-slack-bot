'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _filter2 = require('lodash/filter');

var _filter3 = _interopRequireDefault(_filter2);

exports.activeParticipants = activeParticipants;
exports.direction = direction;
exports.isActive = isActive;
exports.isCall = isCall;
exports.joined = joined;
exports.joinedOnThisDevice = joinedOnThisDevice;
exports.mediaDirection = mediaDirection;
exports.participantIsJoined = participantIsJoined;
exports.remoteParticipant = remoteParticipant;
exports.remoteParticipants = remoteParticipants;
exports.remoteAudioMuted = remoteAudioMuted;
exports.remoteVideoMuted = remoteVideoMuted;
exports.shouldRing = shouldRing;
exports.getState = getState;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Finds the Locus's active participants
 * @param {Types~Locus} locus
 * @private
 * @returns {Array<Types~LocusParticipant>}
 */
/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

function activeParticipants(locus) {
  return (0, _filter3.default)(locus.participants, { state: 'JOINED' });
}

/**
 * Indicates if the locus was activated form this device
 * @param {Types~Locus} locus
 * @private
 * @returns {string} unknown|in|out
 */
function direction(locus) {
  if (!locus || !locus.self) {
    return 'unknown';
  }
  return locus.self.isCreator ? 'out' : 'in';
}

/**
 * Indicates of the specified locus is active
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function isActive(locus) {
  return locus.fullState.state === 'ACTIVE';
}

/**
 * Indicates if the specified locus represents a call (in other words, has
 * exactly two participants)
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function isCall(locus) {
  return locus.participants.filter(function (participant) {
    return participant.type === 'USER';
  }).length === 2;
}

/**
 * Indicates if the current user has joined the Locus
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function joined(locus) {
  return Boolean(locus.self && participantIsJoined(locus.self));
}

/**
 * Indicates if this device has joined the locus
 * @param {ProxySpark} spark
 * @param {Types~Locus} locus
 * @private
 * @returns {Boolean}
 */
function joinedOnThisDevice(spark, locus) {
  return joined(locus) && spark.internal.device.url === locus.self.deviceUrl;
}

/**
 * Indicates the direction of the specified media type for the specified
 * participant
 * @param {string} mediaType
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {string} One of `sendonly`, `recvonly`, `sendrecv`, or `inactive`
 */
function mediaDirection(mediaType, participant) {
  if (!participant) {
    return 'inactive';
  }

  if (!participant.status) {
    return 'inactive';
  }

  return (participant.status[mediaType + 'Status'] || 'inactive').toLowerCase();
}

/**
 * Indicates if the specified participant has joined the Locus
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function participantIsJoined(participant) {
  return participant && participant.state === 'JOINED';
}

/**
 * Finds the party in the call that is not the current user
 * @param {Types~Locus} locus
 * @private
 * @returns {Types~LocusParticipant}
 */
function remoteParticipant(locus) {
  return remoteParticipants(locus)[0];
}

/**
 * Finds all participants of the Locus that are not the current user
 * @param {Types~Locus} locus
 * @private
 * @returns {Types~LocusParticipant}
 */
function remoteParticipants(locus) {
  return locus.participants.filter(function (participant) {
    return participant.type === 'USER' && participant.url !== locus.self.url;
  });
}

/**
 * Indicates if the remote party is sending audio
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function remoteAudioMuted(participant) {
  return participantIsJoined(participant) && !participant.status.audioStatus.includes('SEND');
}

/**
 * Indicates if the remote party is sending video
 * @param {Types~LocusParticipant} participant
 * @private
 * @returns {Boolean}
 */
function remoteVideoMuted(participant) {
  return participantIsJoined(participant) && !participant.status.videoStatus.includes('SEND');
}

/**
 * Indicates if the `call:incoming` event should be fired for the specified Locus
 * @param {Types~MercuryEvent} event Event which delivered the Locus
 * @param {ProxySpark} spark
 * @private
 * @returns {Boolean}
 */
function shouldRing(event) {
  return (0, _get3.default)(event, 'data.locus.self.alertType.action') === 'FULL' && isCall(event.data.locus);
}

// there's really no good way to split getState() up that won't make it less readable
/* eslint-disable complexity */
/**
 * Determines the call state from a locus object. avoids the caching caused by
 * amp state because that leads to out-of-order updates
 * @param {ProxySpark} spark
 * @param {Types~Locus} locus
 * @private
 * @returns {string}
 */
function getState(spark, locus) {
  if (locus) {
    var remote = remoteParticipant(locus);
    if (remote) {
      if (joinedOnThisDevice(spark, locus) && remote && participantIsJoined(remote)) {
        return 'connected';
      }

      var local = locus.self;
      if (remote.state === 'LEFT' || local.state === 'LEFT') {
        return 'disconnected';
      }

      if (remote.state === 'DECLINED') {
        return 'disconnected';
      }

      if (remote.state === 'NOTIFIED') {
        return 'ringing';
      }
    }
  }
  return 'initiated';
}