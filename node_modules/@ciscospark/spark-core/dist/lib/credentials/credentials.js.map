{"version":3,"sources":["credentials.js"],"names":["Credentials","extend","keyFactory","scope","collections","userTokens","dataTypes","token","dataType","derived","canAuthorize","deps","fn","Boolean","supertoken","canRefresh","config","jwtRefreshCallback","props","prop","namespace","session","isRefreshing","default","type","ready","buildLoginUrl","options","clientType","state","Error","client_id","redirect_uri","response_type","toBase64Url","authorizeUrl","stringify","buildLogoutUrl","logoutUrl","goto","cisService","service","constructor","_dataTypes","forEach","key","set","bind","args","getClientToken","logger","info","spark","request","method","uri","tokenUrl","form","grant_type","self_contained_token","auth","user","pass","client_secret","sendImmediately","shouldRefreshAccessToken","then","res","body","parent","catch","statusCode","reject","ErrorConstructor","select","error","_res","getUserToken","resolve","once","get","access_token","downscope","reason","serialize","t","add","initialize","attrs","authorization","prototype","listenToOnce","authorizationString","parsed","parse","query","href","substr","indexOf","invalidate","tokens","models","unset","promises","map","revoke","warn","remove","push","all","refresh","reset","jwt","requestAccessTokenFromJwt","st"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;AAMA;;;;AACA;;;;AACA;;AAOA;;AACA;;;;AAEA;;;;AACA;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;AAGA,IAAMA,cAAc,sBAAYC,MAAZ,SAoKjB,uBAAU,EAACC,YAAY,oBAACC,KAAD;AAAA,WAAWA,KAAX;AAAA,GAAb,EAAV,CApKiB,UAqKjB,kCArKiB,UAyNjB,6BAzNiB,UA2QjB,kCA3QiB,UA8SjB,0CA9SiB,UA+SjB,kCA/SiB,UAAmB;AACrCC,eAAa;AACXC;AADW,GADwB;;AAKrCC,aAAW;AACTC,WAAO,yDAAkCC;AADhC,GAL0B;;AASrCC,WAAS;AACPC,kBAAc;AACZC,YAAM,uDADM;AAMZC,QANY,gBAMP;AACH,eAAOC,QAAQ,KAAKC,UAAL,IAAmB,KAAKA,UAAL,CAAgBJ,YAAnC,IAAmD,KAAKK,UAAhE,CAAP;AACD;AARW,KADP;AAWPA,gBAAY;AACVJ,YAAM,uCADI;AAKVC,QALU,gBAKL;AACH;AACA,YAAI,KAAKI,MAAL,CAAYC,kBAAhB,EAAoC;AAClC,iBAAO,IAAP;AACD;;AAED,eAAOJ,QAAQ,KAAKC,UAAL,IAAmB,KAAKA,UAAL,CAAgBC,UAA3C,CAAP;AACD;AAZS;AAXL,GAT4B;;AAoCrCG,SAAO;AACLJ,gBAAY,yDAAkCK;AADzC,GApC8B;;AAwCrCC,0BAxCqC;;AA0CrCC,WAAS;AACPC,kBAAc;AACZC,eAAS,KADG;AAEZC;AAFY,KADP;AAKP;;;;;;;AAOAC,WAAO;AACLF,eAAS,KADJ;AAELC;AAFK;AAZA,GA1C4B;;AA4DrC;;;;;;;;;AASAE,eArEqC,2BAqEW;AAAA,QAAlCC,OAAkC,uEAAxB,EAACC,oBAAD,EAAwB;;AAC9C;AACA,QAAID,QAAQE,KAAR,IAAiB,CAAC,wBAASF,QAAQE,KAAjB,CAAtB,EAA+C;AAC7C,YAAM,IAAIC,KAAJ,mDAAN;AACD;;AAEDH,YAAQI,SAAR,GAAoB,KAAKf,MAAL,CAAYe,SAAhC;AACAJ,YAAQK,YAAR,GAAuB,KAAKhB,MAAL,CAAYgB,YAAnC;AACAL,YAAQxB,KAAR,GAAgB,KAAKa,MAAL,CAAYb,KAA5B;;AAEAwB,cAAU,yBAAUA,OAAV,CAAV;;AAEA,QAAI,CAACA,QAAQM,aAAb,EAA4B;AAC1BN,cAAQM,aAAR,GAAwBN,QAAQC,UAAR,gCAAxB;AACD;AACD,kCAAuBD,OAAvB;;AAEA,QAAIA,QAAQE,KAAZ,EAAmB;AACjBF,cAAQE,KAAR,GAAgB,eAAOK,WAAP,CAAmB,yBAAeP,QAAQE,KAAvB,CAAnB,CAAhB;AACD;AACD,WAAU,KAAKb,MAAL,CAAYmB,YAAtB,SAAsC,sBAAYC,SAAZ,CAAsBT,OAAtB,CAAtC;AACA;AACD,GA3FoC;;;AA6FrC;;;;;;;AAOAU,gBApGqC,4BAoGR;AAAA,QAAdV,OAAc,uEAAJ,EAAI;;AAC3B,WAAU,KAAKX,MAAL,CAAYsB,SAAtB,SAAmC,sBAAYF,SAAZ,CAAsB,sBAAc;AACrEG,YAAM,KAAKvB,MAAL,CAAYgB,YADmD;AAErEQ,kBAAY,KAAKxB,MAAL,CAAYyB;AAF6C,KAAd,EAGtDd,OAHsD,CAAtB,CAAnC;AAID,GAzGoC;AA2GrCe,aA3GqC,yBA2GhB;AAAA;;AACnB;AACA;AACA,SAAKC,UAAL,GAAkB,yBAAU,KAAKA,UAAf,CAAlB;AACA,wBAAY,KAAKA,UAAjB,EAA6BC,OAA7B,CAAqC,UAACC,GAAD,EAAS;AAC5C,UAAMrC,WAAW,MAAKmC,UAAL,CAAgBE,GAAhB,CAAjB;AACA,UAAIrC,SAASsC,GAAb,EAAkB;AAChBtC,iBAASsC,GAAT,GAAetC,SAASsC,GAAT,CAAaC,IAAb,OAAf;AACD;AACF,KALD;AAMA;;AAVmB,sCAANC,IAAM;AAANA,UAAM;AAAA;;AAWnB,gDAA2B,IAA3B,EAAiCA,IAAjC;AACD,GAvHoC;;;AAyHrC;;;;;;;;;AASAC,gBAlIqC,4BAkIR;AAAA;;AAAA,QAAdtB,OAAc,uEAAJ,EAAI;;AAC3B,SAAKuB,MAAL,CAAYC,IAAZ;;AAEAxB,cAAUA,WAAW,EAArB;AACAA,YAAQxB,KAAR,GAAgBwB,QAAQxB,KAAR,uBAAhB;;AAEA,WAAO,KAAKiD,KAAL,CAAWC,OAAX,CAAmB;AACxB;AACAC,oBAFwB;AAGxBC,WAAK,KAAKvC,MAAL,CAAYwC,QAHO;AAIxBC,YAAM;AACJC,wCADI;AAEJvD,eAAOwB,QAAQxB,KAFX;AAGJwD,8BAAsB;AAHlB,OAJkB;AASxBC,YAAM;AACJC,cAAM,KAAK7C,MAAL,CAAYe,SADd;AAEJ+B,cAAM,KAAK9C,MAAL,CAAY+C,aAFd;AAGJC,yBAAiB;AAHb,OATkB;AAcxBC,gCAA0B;AAC1B;AAfwB,KAAnB,EAiBLC,IAjBK,CAiBA,UAACC,GAAD;AAAA,aAAS,oBAAUA,IAAIC,IAAd,EAAoB,EAACC,cAAD,EAApB,CAAT;AAAA,KAjBA,EAkBLC,KAlBK,CAkBC,UAACH,GAAD,EAAS;AACd,UAAIA,IAAII,UAAJ,KAAmB,GAAvB,EAA4B;AAC1B,eAAO,kBAAQC,MAAR,CAAeL,GAAf,CAAP;AACD;;AAED,UAAMM,mBAAmB,sBAAYC,MAAZ,CAAmBP,IAAIC,IAAJ,CAASO,KAA5B,CAAzB;AACA,aAAO,kBAAQH,MAAR,CAAe,IAAIC,gBAAJ,CAAqBN,IAAIS,IAAJ,IAAYT,GAAjC,CAAf,CAAP;AACD,KAzBK,CAAP;AA0BD,GAlKoC;;AAsKrC;;;;;;;;;AASAU,cA/KqC,wBA+KxB1E,KA/KwB,EA+KjB;AAAA;;AAClB,WAAO,kBAAQ2E,OAAR,CAAgB,CAAC,KAAKxD,YAAN,IAAsB,sBAAY,UAACwD,OAAD,EAAa;AACpE,aAAK5B,MAAL,CAAYC,IAAZ;AACA,aAAK4B,IAAL,wBAAiC,YAAM;AACrC,eAAK7B,MAAL,CAAYC,IAAZ;AACA2B;AACD,OAHD;AAID,KAN4C,CAAtC,EAONZ,IAPM,CAOD,YAAM;AACV,UAAI,CAAC,OAAKxD,YAAV,EAAwB;AACtB,eAAKwC,MAAL,CAAYC,IAAZ;AACA,eAAO,kBAAQqB,MAAR,CAAe,IAAI1C,KAAJ,gDAAf,CAAP;AACD;;AAED,UAAI,CAAC3B,KAAL,EAAY;AACVA,gBAAQ,qCAAyB,OAAKa,MAAL,CAAYb,KAArC,CAAR;AACD;;AAEDA,cAAQ,sBAAUA,KAAV,CAAR;;AAEA,UAAIA,UAAU,sBAAU,OAAKa,MAAL,CAAYb,KAAtB,CAAd,EAA4C;AAC1C,eAAO,kBAAQ2E,OAAR,CAAgB,OAAKhE,UAArB,CAAP;AACD;;AAED,UAAMP,QAAQ,OAAKF,UAAL,CAAgB2E,GAAhB,CAAoB7E,KAApB,CAAd;;AAEA;AACA;AACA,UAAI,CAACI,KAAD,IAAU,CAACA,MAAM0E,YAArB,EAAmC;AACjC,eAAO,OAAKnE,UAAL,CAAgBoE,SAAhB,CAA0B/E,KAA1B,EACJmE,KADI,CACE,UAACa,MAAD,EAAY;AACjB,iBAAKjC,MAAL,CAAYyB,KAAZ,qDAAoExE,KAApE,EAA6EgF,MAA7E;AACA,iBAAKjC,MAAL,CAAYyB,KAAZ,kDAAiExE,KAAjE;AACA,iBAAO,kBAAQ2E,OAAR,CAAgB,oBAAU,sBAAc,EAAC3E,YAAD,EAAd,EAAuB,OAAKW,UAAL,CAAgBsE,SAAhB,EAAvB,CAAV,CAAhB,EAAgF,EAACf,cAAD,EAAhF,CAAP;AACD,SALI,EAMJH,IANI,CAMC,iBAAI,UAACmB,CAAD;AAAA,iBAAO,OAAKhF,UAAL,CAAgBiF,GAAhB,CAAoBD,CAApB,CAAP;AAAA,SAAJ,CAND,CAAP;AAOD;;AAED,aAAO,kBAAQP,OAAR,CAAgBvE,KAAhB,CAAP;AACD,KAtCM,CAAP;AAuCD,GAvNoC;;AA0NrC;;;;;;;;;AASAgF,YAnOqC,sBAmO1BC,KAnO0B,EAmOnB7D,OAnOmB,EAmOV;AAAA;;AACzB,QAAI6D,KAAJ,EAAW;AACT,UAAI,OAAOA,KAAP,aAAJ,EAA+B;AAC7B,aAAK1E,UAAL,GAAkB0E,KAAlB;AACD;;AAED,UAAIA,MAAMP,YAAV,EAAwB;AACtB,aAAKnE,UAAL,GAAkB0E,KAAlB;AACD;;AAED,UAAIA,MAAMC,aAAV,EAAyB;AACvB,YAAID,MAAMC,aAAN,CAAoB3E,UAAxB,EAAoC;AAClC,eAAKA,UAAL,GAAkB0E,MAAMC,aAAN,CAAoB3E,UAAtC;AACD,SAFD,MAGK;AACH,eAAKA,UAAL,GAAkB0E,MAAMC,aAAxB;AACD;AACF;AACF;;AAED,yBAAc,sBAAYC,SAAZ,CAAsBH,UAApC,EAAgD,IAAhD,EAAsD,CAACC,KAAD,EAAQ7D,OAAR,CAAtD;;AAEA,SAAKgE,YAAL,CAAkB,KAAKtB,MAAvB,mBAAgD,YAAM;AACpD,UAAI,OAAKrD,MAAL,CAAY4E,mBAAhB,EAAqC;AACnC,YAAMC,SAAS,cAAIC,KAAJ,CAAU,OAAK9E,MAAL,CAAY4E,mBAAtB,EAA2C,IAA3C,CAAf;AACA;AACA,eAAK5E,MAAL,CAAYe,SAAZ,GAAwB8D,OAAOE,KAAP,CAAahE,SAArC;AACA,eAAKf,MAAL,CAAYgB,YAAZ,GAA2B6D,OAAOE,KAAP,CAAa/D,YAAxC;AACA,eAAKhB,MAAL,CAAYb,KAAZ,GAAoB0F,OAAOE,KAAP,CAAa5F,KAAjC;AACA,eAAKa,MAAL,CAAYmB,YAAZ,GAA2B0D,OAAOG,IAAP,CAAYC,MAAZ,CAAmB,CAAnB,EAAsBJ,OAAOG,IAAP,CAAYE,OAAZ,KAAtB,CAA3B;AACA;AACD;AACF,KAVD;;AAYA,SAAK9C,KAAL,CAAW2B,IAAX,WAA0B,YAAM;AAC9B,aAAKtD,KAAL,GAAa,IAAb;AACD,KAFD;AAGD,GAxQoC;;AA4QrC;;;;;;AAMA0E,YAlRqC,wBAkRxB;AAAA;;AACX,SAAKjD,MAAL,CAAYC,IAAZ;AACA,QAAMiD,SAAS,KAAK/F,UAAL,CAAgBgG,MAA/B;AACA,QAAMvF,aAAa,KAAKA,UAAxB;;AAEA,SAAKwF,KAAL;;AAEA,QAAMC,WAAWH,OAAOI,GAAP,CAAW,UAACjG,KAAD,EAAW;AACrC,aAAK2C,MAAL,CAAYC,IAAZ,sCAAoD5C,MAAMJ,KAA1D;AACA,aAAOI,MAAMkG,MAAN,GACJnC,KADI,CACE,UAACa,MAAD;AAAA,eAAY,OAAKjC,MAAL,CAAYwD,IAAZ,8CAA4DnG,MAAMJ,KAAlE,EAA2EgF,MAA3E,CAAZ;AAAA,OADF;AAEL;AACA;AACA;AAJK,OAKJjB,IALI,CAKC;AAAA,eAAM,OAAK7D,UAAL,CAAgBsG,MAAhB,CAAuBpG,MAAMJ,KAA7B,CAAN;AAAA,OALD,CAAP;AAMD,KARgB,CAAjB;;AAWA,QAAIW,UAAJ,EAAgB;AACdyF,eAASK,IAAT,CAAc9F,WAAW2F,MAAX,GACXnC,KADW,CACL,UAACa,MAAD;AAAA,eAAY,OAAKjC,MAAL,CAAYwD,IAAZ,6CAA6DvB,MAA7D,CAAZ;AAAA,OADK,CAAd;AAED;;AAED,WAAO,kBAAQ0B,GAAR,CAAYN,QAAZ,EACJrC,IADI,CACC,iBAAI;AAAA,aAAM,OAAKhB,MAAL,CAAYC,IAAZ,mCAAN;AAAA,KAAJ,CADD,CAAP;AAED,GA3SoC;;AAgTrC;;;;;;;;;AASA2D,SAzTqC,qBAyT3B;AAAA;;AACR,SAAK5D,MAAL,CAAYC,IAAZ;;AAEA,QAAMrC,aAAa,KAAKA,UAAxB;AACA,QAAMsF,SAAS,KAAK/F,UAAL,CAAgBgG,MAA/B;;AAEA,SAAKhG,UAAL,CAAgB0G,KAAhB;AACA,SAAKT,KAAL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,KAAKtF,MAAL,CAAYC,kBAAhB,EAAoC;AAClC,aAAO,KAAKD,MAAL,CAAYC,kBAAZ,CAA+B,KAAKmC,KAApC,EACJc,IADI,CACC,UAAC8C,GAAD;AAAA,eAAS,OAAK5D,KAAL,CAAWqC,aAAX,CAAyBwB,yBAAzB,CAAmD,EAACD,QAAD,EAAnD,CAAT;AAAA,OADD,CAAP;AAED;;AAGD,WAAOlG,WAAWgG,OAAX,GACJ5C,IADI,CACC,iBAAI,YAAM;AACdkC,aAAOxD,OAAP,CAAe,UAACrC,KAAD,EAAW;AACxB,eAAK2C,MAAL,CAAYC,IAAZ,sCAAoD5C,MAAMJ,KAA1D;AACAI,cAAMkG,MAAN;AACD,OAHD;AAID,KALK,CADD,EAOJvC,IAPI,CAOC,UAACgD,EAAD,EAAQ;AACZ,aAAKpG,UAAL,GAAkBoG,EAAlB;AACD,KATI,CAAP;AAUD,GAxVoC;AAAA;AAAA,CAAnB,wiBAApB;;kBA2VelH,W","file":"credentials.js","sourcesContent":["\n/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport querystring from 'querystring';\nimport url from 'url';\nimport {\n  base64,\n  makeStateDataType,\n  oneFlight,\n  tap,\n  whileInFlight\n} from '@ciscospark/common';\nimport {persist, waitForValue} from '../storage/decorators';\nimport SparkPlugin from '../spark-plugin';\nimport {cloneDeep, isObject} from 'lodash';\nimport TokenCollection from './token-collection';\nimport {filterScope, sortScope} from './scope';\nimport Token from './token';\nimport grantErrors from './grant-errors';\n\n/**\n * @class\n */\nconst Credentials = SparkPlugin.extend({\n  collections: {\n    userTokens: TokenCollection\n  },\n\n  dataTypes: {\n    token: makeStateDataType(Token, `token`).dataType\n  },\n\n  derived: {\n    canAuthorize: {\n      deps: [\n        `supertoken`,\n        `supertoken.canAuthorize`,\n        `canRefresh`\n      ],\n      fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: [\n        `supertoken`,\n        `supertoken.canRefresh`\n      ],\n      fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n\n  props: {\n    supertoken: makeStateDataType(Token, `token`).prop\n  },\n\n  namespace: `Credentials`,\n\n  session: {\n    isRefreshing: {\n      default: false,\n      type: `boolean`\n    },\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link SparkPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: `boolean`\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl(options = {clientType: `public`}) {\n    /* eslint-disable camelcase */\n    if (options.state && !isObject(options.state)) {\n      throw new Error(`if specified, \\`options.state\\` must be an object`);\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n\n    options = cloneDeep(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === `public` ? `token` : `code`;\n    }\n    Reflect.deleteProperty(options, `clientType`);\n\n    if (options.state) {\n      options.state = base64.toBase64Url(JSON.stringify(options.state));\n    }\n    return `${this.config.authorizeUrl}?${querystring.stringify(options)}`;\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl(options = {}) {\n    return `${this.config.logoutUrl}?${querystring.stringify(Object.assign({\n      goto: this.config.redirect_uri,\n      cisService: this.config.service\n    }, options))}`;\n  },\n\n  constructor(...args) {\n    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n    this._dataTypes = cloneDeep(this._dataTypes);\n    Object.keys(this._dataTypes).forEach((key) => {\n      const dataType = this._dataTypes[key];\n      if (dataType.set) {\n        dataType.set = dataType.set.bind(this);\n      }\n    });\n    // END HACK\n    Reflect.apply(SparkPlugin, this, args);\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken(options = {}) {\n    this.logger.info(`credentials: requesting client credentials grant`);\n\n    options = options || {};\n    options.scope = options.scope || `webexsquare:admin`;\n\n    return this.spark.request({\n      /* eslint-disable camelcase */\n      method: `POST`,\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: `client_credentials`,\n        scope: options.scope,\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n    })\n     .then((res) => new Token(res.body, {parent: this}))\n     .catch((res) => {\n       if (res.statusCode !== 400) {\n         return Promise.reject(res);\n       }\n\n       const ErrorConstructor = grantErrors.select(res.body.error);\n       return Promise.reject(new ErrorConstructor(res._res || res));\n     });\n  },\n\n  @oneFlight({keyFactory: (scope) => scope})\n  @waitForValue(`@`)\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(spark.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken(scope) {\n    return Promise.resolve(!this.isRefreshing || new Promise((resolve) => {\n      this.logger.info(`credentials: token refresh inflight; delaying getUserToken until refresh completes`);\n      this.once(`change:isRefreshing`, () => {\n        this.logger.info(`credentials: token refresh complete; reinvoking getUserToken`);\n        resolve();\n      });\n    }))\n    .then(() => {\n      if (!this.canAuthorize) {\n        this.logger.info(`credentials: cannot produce an access token from current state`);\n        return Promise.reject(new Error(`Current state cannot produce an access token`));\n      }\n\n      if (!scope) {\n        scope = filterScope(`spark:kms`, this.config.scope);\n      }\n\n      scope = sortScope(scope);\n\n      if (scope === sortScope(this.config.scope)) {\n        return Promise.resolve(this.supertoken);\n      }\n\n      const token = this.userTokens.get(scope);\n\n      // we should also check for the token.access_token since token object does\n      // not get cleared on unsetting while logging out.\n      if (!token || !token.access_token) {\n        return this.supertoken.downscope(scope)\n          .catch((reason) => {\n            this.logger.error(`credentials: failed to downscope supertoken to ${scope}`, reason);\n            this.logger.error(`credentials: falling back to supertoken for ${scope}`);\n            return Promise.resolve(new Token(Object.assign({scope}, this.supertoken.serialize())), {parent: this});\n          })\n          .then(tap((t) => this.userTokens.add(t)));\n      }\n\n      return Promise.resolve(token);\n    });\n  },\n\n  @persist(`@`)\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize(attrs, options) {\n    if (attrs) {\n      if (typeof attrs === `string`) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        }\n        else {\n          this.supertoken = attrs.authorization;\n        }\n      }\n    }\n\n    Reflect.apply(SparkPlugin.prototype.initialize, this, [attrs, options]);\n\n    this.listenToOnce(this.parent, `change:config`, () => {\n      if (this.config.authorizationString) {\n        const parsed = url.parse(this.config.authorizationString, true);\n        /* eslint-disable camelcase */\n        this.config.client_id = parsed.query.client_id;\n        this.config.redirect_uri = parsed.query.redirect_uri;\n        this.config.scope = parsed.query.scope;\n        this.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf(`?`));\n        /* eslint-enable camelcase */\n      }\n    });\n\n    this.spark.once(`loaded`, () => {\n      this.ready = true;\n    });\n  },\n\n  @oneFlight\n  @waitForValue(`@`)\n  /**\n   * Revokes all tokens and clears them from the stores.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate() {\n    this.logger.info(`credentials: invalidating tokens`);\n    const tokens = this.userTokens.models;\n    const supertoken = this.supertoken;\n\n    this.unset(`supertoken`);\n\n    const promises = tokens.map((token) => {\n      this.logger.info(`credentials: revoking token for ${token.scope}`);\n      return token.revoke()\n        .catch((reason) => this.logger.warn(`credentials: failed to revoke token for ${token.scope}`, reason))\n        // Note: can't pass the whole token object to remove (amp state will\n        // implicity call toString() on it which a. is inefficient and b. will\n        // fail once the token is revoked)\n        .then(() => this.userTokens.remove(token.scope));\n    });\n\n\n    if (supertoken) {\n      promises.push(supertoken.revoke()\n        .catch((reason) => this.logger.warn(`credentials: failed to revoke supertoken`, reason)));\n    }\n\n    return Promise.all(promises)\n      .then(tap(() => this.logger.info(`credentials: invalidated tokens`)));\n  },\n\n  @oneFlight\n  @whileInFlight(`isRefreshing`)\n  @waitForValue(`@`)\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh() {\n    this.logger.info(`credentials: refresh requested`);\n\n    const supertoken = this.supertoken;\n    const tokens = this.userTokens.models;\n\n    this.userTokens.reset();\n    this.unset(`supertoken`);\n\n    // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.spark)\n        .then((jwt) => this.spark.authorization.requestAccessTokenFromJwt({jwt}));\n    }\n\n\n    return supertoken.refresh()\n      .then(tap(() => {\n        tokens.forEach((token) => {\n          this.logger.info(`credentials: revoking token for ${token.scope}`);\n          token.revoke();\n        });\n      }))\n      .then((st) => {\n        this.supertoken = st;\n      });\n  }\n});\n\nexport default Credentials;\n"]}