{"version":3,"sources":["memory-store-adapter.js"],"names":["_bind","namespace","options","reject","Error","logger","map","data","forEach","key","set","info","resolve","clear","del","delete","get","res","put","value","bind","preload"],"mappings":";;;;;;;;;;;;;;;;;;AAMA;;;;AAEA;;;;;;;;AAQA,SAASA,KAAT,CAAeC,SAAf,EAAwC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AACtCA,YAAUA,WAAW,EAArB;AACA,MAAI,CAACD,SAAL,EAAgB;AACd,WAAO,kBAAQE,MAAR,CAAe,IAAIC,KAAJ,2BAAf,CAAP;AACD;;AAED,MAAI,CAACF,QAAQG,MAAb,EAAqB;AACnB,WAAO,kBAAQF,MAAR,CAAe,IAAIC,KAAJ,gCAAf,CAAP;AACD;;AAED,MAAMC,SAASH,QAAQG,MAAvB;;AAEA,MAAMC,MAAM,mBAAZ;AACA,MAAIJ,QAAQK,IAAZ,EAAkB;AAChB,wBAAYL,QAAQK,IAApB,EAA0BC,OAA1B,CAAkC,UAACC,GAAD,EAAS;AACzCH,UAAII,GAAJ,CAAQD,GAAR,EAAaP,QAAQK,IAAR,CAAaE,GAAb,CAAb;AACD,KAFD;AAGD;;AAEDJ,SAAOM,IAAP;AACA,SAAO,kBAAQC,OAAR,CAAgB;AACrBC,SADqB,mBACb;AACNR,aAAOM,IAAP;AACA,aAAO,kBAAQC,OAAR,CAAgBN,IAAIO,KAAJ,EAAhB,CAAP;AACD,KAJoB;AAKrBC,OALqB,eAKjBL,GALiB,EAKZ;AACPJ,aAAOM,IAAP,sCAAgDF,GAAhD;AACA,aAAO,kBAAQG,OAAR,CAAgBN,IAAIS,MAAJ,CAAWN,GAAX,CAAhB,CAAP;AACD,KARoB;AASrBO,OATqB,eASjBP,GATiB,EASZ;AACPJ,aAAOM,IAAP,qCAA+CF,GAA/C;AACA,UAAMQ,MAAMX,IAAIU,GAAJ,CAAQP,GAAR,CAAZ;AACA,UAAI,OAAOQ,GAAP,gBAAJ,EAAgC;AAC9B,eAAO,kBAAQd,MAAR,CAAe,2BAAf,CAAP;AACD;;AAED,aAAO,kBAAQS,OAAR,CAAgBK,GAAhB,CAAP;AACD,KAjBoB;AAkBrBC,OAlBqB,eAkBjBT,GAlBiB,EAkBZU,KAlBY,EAkBL;AACdd,aAAOM,IAAP,qCAA+CF,GAA/C;AACA,aAAO,kBAAQG,OAAR,CAAgBN,IAAII,GAAJ,CAAQD,GAAR,EAAaU,KAAb,CAAhB,CAAP;AACD;AArBoB,GAAhB,CAAP;AAuBD,C,CA3DD;;;;;;kBA6De;AACbC,QAAMpB,KADO;AAEbqB,SAFa,mBAELd,IAFK,EAEC;AACZ,WAAO;AACLa,UADK,gBACAnB,SADA,EACyB;AAAA,YAAdC,OAAc,uEAAJ,EAAI;;AAC5B,YAAIK,KAAKN,SAAL,CAAJ,EAAqB;AACnBC,kBAAQK,IAAR,GAAeA,KAAKN,SAAL,CAAf;AACD;;AAED,eAAOD,MAAMC,SAAN,EAAiBC,OAAjB,CAAP;AACD;AAPI,KAAP;AASD;AAZY,C","file":"memory-store-adapter.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport {NotFoundError} from './errors';\n\n/**\n * Binds a namespace\n * @param {string} namespace\n * @param {Object} options\n * @param {Object} options.data\n * @private\n * @returns {Promise<Object>}\n */\nfunction _bind(namespace, options = {}) {\n  options = options || {};\n  if (!namespace) {\n    return Promise.reject(new Error(`\\`namespace\\` is required`));\n  }\n\n  if (!options.logger) {\n    return Promise.reject(new Error(`\\`options.logger\\` is required`));\n  }\n\n  const logger = options.logger;\n\n  const map = new Map();\n  if (options.data) {\n    Object.keys(options.data).forEach((key) => {\n      map.set(key, options.data[key]);\n    });\n  }\n\n  logger.info(`memory-store-adapter: returning binding`);\n  return Promise.resolve({\n    clear() {\n      logger.info(`memory-store-adapter: clearing the binding`);\n      return Promise.resolve(map.clear());\n    },\n    del(key) {\n      logger.info(`memory-store-adapter: deleting \\`${key}\\``);\n      return Promise.resolve(map.delete(key));\n    },\n    get(key) {\n      logger.info(`memory-store-adapter: reading \\`${key}\\``);\n      const res = map.get(key);\n      if (typeof res === `undefined`) {\n        return Promise.reject(new NotFoundError());\n      }\n\n      return Promise.resolve(res);\n    },\n    put(key, value) {\n      logger.info(`memory-store-adapter: writing \\`${key}\\``);\n      return Promise.resolve(map.set(key, value));\n    }\n  });\n}\n\nexport default {\n  bind: _bind,\n  preload(data) {\n    return {\n      bind(namespace, options = {}) {\n        if (data[namespace]) {\n          options.data = data[namespace];\n        }\n\n        return _bind(namespace, options);\n      }\n    };\n  }\n};\n"]}