{"version":3,"sources":["authorization.js"],"names":["Authorization","extend","derived","isAuthenticating","deps","fn","isAuthorizing","session","default","type","namespace","requestAuthorizationCodeGrant","options","logger","info","code","reject","Error","spark","request","method","uri","config","tokenUrl","form","grant_type","redirect_uri","self_contained_token","auth","user","client_id","pass","client_secret","sendImmediately","shouldRefreshAccessToken","then","res","credentials","set","supertoken","body","catch","statusCode","ErrorConstructor","select","error","_res","requestAccessTokenFromJwt","jwt","service","resource","headers","authorization","access_token","token","token_type","expires_in","expiresIn"],"mappings":";;;;;;;;;;;;;;+BAAA;;;;;;AAMA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;AAKA,IAAMA,gBAAgB,uBAAYC,MAAZ,SA+BnB,2CA/BmB,UAAmB;AACvCC,WAAS;AACP;;;;;;AAMAC,sBAAkB;AAChBC,YAAM,iBADU;AAEhBC,QAFgB,gBAEX;AACH,eAAO,KAAKC,aAAZ;AACD;AAJe;AAPX,GAD8B;;AAgBvCC,WAAS;AACP;;;;;;AAMAD,mBAAe;AACbE,eAAS,KADI;AAEbC;AAFa;AAPR,GAhB8B;;AA6BvCC,0BA7BuC;;AAiCvC;;;;;;;;AAQAC,+BAzCuC,2CAyCK;AAAA;;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC1C,SAAKC,MAAL,CAAYC,IAAZ;;AAEA,QAAI,CAACF,QAAQG,IAAb,EAAmB;AACjB,aAAO,kBAAQC,MAAR,CAAe,IAAIC,KAAJ,8BAAf,CAAP;AACD;;AAED,WAAO,KAAKC,KAAL,CAAWC,OAAX,CAAmB;AACxBC,oBADwB;AAExBC,WAAK,KAAKC,MAAL,CAAYC,QAFO;AAGxBC,YAAM;AACJC,wCADI;AAEJC,sBAAc,KAAKJ,MAAL,CAAYI,YAFtB;AAGJX,cAAMH,QAAQG,IAHV;AAIJY,8BAAsB;AAJlB,OAHkB;AASxBC,YAAM;AACJC,cAAM,KAAKP,MAAL,CAAYQ,SADd;AAEJC,cAAM,KAAKT,MAAL,CAAYU,aAFd;AAGJC,yBAAiB;AAHb,OATkB;AAcxBC,gCAA0B;AAdF,KAAnB,EAgBJC,IAhBI,CAgBC,UAACC,GAAD,EAAS;AACb,YAAKlB,KAAL,CAAWmB,WAAX,CAAuBC,GAAvB,CAA2B,EAACC,YAAYH,IAAII,IAAjB,EAA3B;AACD,KAlBI,EAmBJC,KAnBI,CAmBE,UAACL,GAAD,EAAS;AACd,UAAIA,IAAIM,UAAJ,KAAmB,GAAvB,EAA4B;AAC1B,eAAO,kBAAQ1B,MAAR,CAAeoB,GAAf,CAAP;AACD;;AAED,UAAMO,mBAAmB,uBAAYC,MAAZ,CAAmBR,IAAII,IAAJ,CAASK,KAA5B,CAAzB;AACA,aAAO,kBAAQ7B,MAAR,CAAe,IAAI2B,gBAAJ,CAAqBP,IAAIU,IAAJ,IAAYV,GAAjC,CAAf,CAAP;AACD,KA1BI,CAAP;AA2BD,GA3EsC;;AA8EvC;;;;;;;;;;;;;AAaAW,2BA3FuC,2CA2FN;AAAA;;AAAA,QAANC,GAAM,QAANA,GAAM;;AAC/B,WAAO,KAAK9B,KAAL,CAAWC,OAAX,CAAmB;AACxBC,oBADwB;AAExB6B,sBAFwB;AAGxBC,2BAHwB;AAIxBC,eAAS;AACPC,uBAAeJ;AADR;AAJe,KAAnB,EAQJb,IARI,CAQC;AAAA,UAAEK,IAAF,SAAEA,IAAF;AAAA,aAAa;AACjBa,sBAAcb,KAAKc,KADF;AAEjBC,4BAFiB;AAGjBC,oBAAYhB,KAAKiB;AAHA,OAAb;AAAA,KARD,EAaJtB,IAbI,CAaC,UAACmB,KAAD,EAAW;AACf,aAAKpC,KAAL,CAAWmB,WAAX,CAAuBC,GAAvB,CAA2B;AACzBC,oBAAYe;AADa,OAA3B;AAGD,KAjBI,CAAP;AAkBD,GA9GsC;AAAA;AAAA,CAAnB,mWAAtB;;kBAiHetD,a","file":"authorization.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @ignore\n */\n\n/* eslint camelcase: [0] */\n\nimport {oneFlight, whileInFlight} from '@ciscospark/common';\nimport {grantErrors, SparkPlugin} from '@ciscospark/spark-core';\n\n/**\n * NodeJS support for OAuth2\n * @class\n * @variation 2\n */\nconst Authorization = SparkPlugin.extend({\n  derived: {\n    /**\n     * Alias of {@link Authorization(2)#isAuthorizing}\n     * @instance\n     * @memberof Authorization(2)\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: [`isAuthorizing`],\n      fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof Authorization(2)\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: `boolean`\n    }\n  },\n\n  namespace: `Credentials`,\n\n  @whileInFlight(`isAuthorizing`)\n  @oneFlight\n  /**\n   * Exchanges an authorization code for an access token\n   * @instance\n   * @memberof Authorization(2)\n   * @param {Object} options\n   * @param {Object} options.code\n   * @returns {Promise}\n   */\n  requestAuthorizationCodeGrant(options = {}) {\n    this.logger.info(`credentials: requesting authorization code grant`);\n\n    if (!options.code) {\n      return Promise.reject(new Error(`\\`options.code\\` is required`));\n    }\n\n    return this.spark.request({\n      method: `POST`,\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: `authorization_code`,\n        redirect_uri: this.config.redirect_uri,\n        code: options.code,\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then((res) => {\n        this.spark.credentials.set({supertoken: res.body});\n      })\n      .catch((res) => {\n        if (res.statusCode !== 400) {\n          return Promise.reject(res);\n        }\n\n        const ErrorConstructor = grantErrors.select(res.body.error);\n        return Promise.reject(new ErrorConstructor(res._res || res));\n      });\n  },\n\n  @oneFlight\n  /**\n   * Requests a Cisco Spark access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(spark)` for automatic token refresh to\n   * work.\n   *\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt({jwt}) {\n    return this.spark.request({\n      method: `POST`,\n      service: `hydra`,\n      resource: `jwt/login`,\n      headers: {\n        authorization: jwt\n      }\n    })\n      .then(({body}) => ({\n        access_token: body.token,\n        token_type: `Bearer`,\n        expires_in: body.expiresIn\n      }))\n      .then((token) => {\n        this.spark.credentials.set({\n          supertoken: token\n        });\n      });\n  }\n});\n\nexport default Authorization;\n"]}